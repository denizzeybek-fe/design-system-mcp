{
  "_metadata": {
    "lastUpdated": "2025-11-25T14:48:39.823Z",
    "propsHash": "0b2c0ec016be",
    "eventsHash": "0de5e4df1f1d",
    "propCount": 73,
    "eventCount": 18
  },
  "component": "InRichTextInput",
  "propEnrichments": {
    "value": {
      "description": "Input content with dynamic tags (v-model)",
      "valueFormat": {
        "structure": "string with tag placeholders",
        "notes": "HTML/rich text content with embedded dynamic content tags. Use v-model for two-way binding. Content can include toolbar formatting (bold, italic, links), dynamic tags ({{attribute}}), and WhatsApp styling (*bold*, _italic_) if enabled. Listen to @purify event to get sanitized output for saving.",
        "typescript": "string",
        "example": "v-model=\"content\" // '<p>Hello {{first_name}}, welcome!</p>'"
      }
    },
    "labelText": {
      "description": "Label text for the input",
      "valueFormat": {
        "structure": "string",
        "notes": "Label text displayed above the rich text editor. Shown when labelStatus=true. Use clear, descriptive labels to help users understand the field purpose (e.g., 'Message Content', 'Email Body', 'SMS Text').",
        "typescript": "string",
        "example": "label-text=\"Message Content\""
      }
    },
    "dynamicContentList": {
      "description": "Available dynamic content attributes - replaces V1 attributeList",
      "valueFormat": {
        "structure": "Array of attribute objects",
        "notes": "CRITICAL: Defines insertable dynamic content/merge tags for personalized messages. Each attribute needs 'label' (shown in dropdown) and 'value' (inserted as {{value}}). Optional: 'category' for grouping, 'icon' for visual distinction. Used for email templates, SMS campaigns, push notifications with user data. Example: user selects 'First Name', {{first_name}} gets inserted and later replaced with actual name.",
        "typescript": "Array<{ label: string; value: string; category?: string; icon?: string; }>",
        "example": ":dynamic-content-list=\"[{ label: 'First Name', value: 'first_name', category: 'User' }]\""
      },
      "commonMistakes": [
        {
          "mistake": "Using attributeList from V1",
          "impact": "Prop not recognized - no dynamic content available in dropdown",
          "fix": "Change to dynamicContentList: :dynamic-content-list=\"attributes\"",
          "severity": "high"
        }
      ]
    },
    "toolbarOptions": {
      "description": "Configure visible toolbar buttons",
      "valueFormat": {
        "structure": "Array of toolbar option strings",
        "notes": "Defines which formatting tools appear in the editor toolbar. Common options: 'bold', 'italic', 'underline' for text styling, 'link' for URLs, 'emoji' for emoji picker, 'dynamicContent' for merge tags. Customize based on use case: SMS uses minimal ['bold', 'italic', 'dynamicContent'], email uses full formatting. Order in array determines button order.",
        "typescript": "Array<'bold' | 'italic' | 'underline' | 'link' | 'emoji' | 'dynamicContent'>",
        "example": ":toolbar-options=\"['bold', 'italic', 'link', 'emoji', 'dynamicContent']\""
      }
    },
    "footerOptions": {
      "description": "Configure footer elements",
      "valueFormat": {
        "structure": "Array of footer option strings",
        "notes": "Controls what appears in the editor footer area. 'counter' shows character/word count (requires characterCounterStatus=true), 'label' displays footerLabel text, 'tags' shows list of used dynamic content tags. Useful for giving users real-time feedback on message length and dynamic content usage.",
        "typescript": "Array<'counter' | 'label' | 'tags'>",
        "example": ":footer-options=\"['counter', 'tags']\""
      }
    },
    "helperTextValidationConfig": {
      "description": "Validation configuration - replaces V1 textValidateConfig",
      "valueFormat": {
        "structure": "Object with validation rules",
        "notes": "Validation rules for rich text content. maxLength enforces character limit (critical for SMS 160 chars), minLength requires minimum content, segmentLength shows message segmentation for SMS (each segment = 160 chars). Validation messages appear via states/stateMessage props. Essential for channels with strict length limits.",
        "typescript": "{ maxLength?: number; minLength?: number; segmentLength?: number; }",
        "example": ":helper-text-validation-config=\"{ maxLength: 160, segmentLength: 160 }\""
      }
    },
    "helperTextValidationConfigStatus": {
      "description": "Enable helper text validation display",
      "valueFormat": {
        "structure": "boolean",
        "notes": "When true, enables validation feedback based on helperTextValidationConfig rules. Shows warning/error states when limits are approached or exceeded. Use with states and stateMessage props to provide user feedback. Essential for enforcing content constraints.",
        "typescript": "boolean",
        "example": "helper-text-validation-config-status"
      }
    },
    "states": {
      "description": "Validation state - replaces V1 invalid/warning",
      "valueFormat": {
        "structure": "string enum",
        "notes": "Visual validation state for the editor. 'default' for normal, 'success' for valid, 'warning' for approaching limits (e.g., 150/160 chars), 'error' for invalid/exceeded limits. Replaces V1's separate invalid and warning boolean props. Use with stateMessage to explain the validation issue.",
        "typescript": "'default' | 'success' | 'warning' | 'error'",
        "possibleValues": [
          "default",
          "success",
          "warning",
          "error"
        ],
        "example": "states=\"warning\" // When approaching SMS limit"
      }
    },
    "stateMessage": {
      "description": "Message for validation state",
      "valueFormat": {
        "structure": "string",
        "notes": "Explanatory message shown with validation state. Appears below editor when states is set to warning/error. Provide clear, actionable feedback: 'Required field', 'Maximum 160 characters', 'Message will be split into 2 SMS'. Critical for user understanding of validation rules.",
        "typescript": "string",
        "example": "state-message=\"Message exceeds SMS limit and will be split into multiple messages\""
      }
    },
    "characterCounterStatus": {
      "description": "Show character counter - replaces V1 isCounter",
      "valueFormat": {
        "structure": "boolean",
        "notes": "Shows character/word count in footer. Requires footerOptions to include 'counter'. Count respects helperTextValidationConfig.maxLength (e.g., '45/160'). Essential for SMS (160 char limit), Twitter-like interfaces, or any character-limited content. Use customCounter for custom counting logic.",
        "typescript": "boolean",
        "example": "character-counter-status :footer-options=\"['counter']\""
      }
    },
    "maxSelectableDynamicContent": {
      "description": "Maximum dynamic content tags allowed",
      "valueFormat": {
        "structure": "number",
        "notes": "Limits how many dynamic content tags can be inserted into the message. 0 (default) means unlimited. When limit reached, dynamic content button becomes disabled. Useful for enforcing business rules like 'max 5 personalization fields per SMS' or preventing over-personalization that hurts deliverability.",
        "typescript": "number",
        "example": ":max-selectable-dynamic-content=\"5\" // Max 5 dynamic tags"
      }
    },
    "isDynamicContentOnly": {
      "description": "Only allow dynamic content (no free text)",
      "valueFormat": {
        "structure": "boolean",
        "notes": "When true, users can ONLY insert dynamic content tags - no free text allowed. Useful for strict templating scenarios where content must be entirely composed of predefined attributes. Example: webhook payload builder where only valid field names are allowed.",
        "typescript": "boolean",
        "example": "is-dynamic-content-only // Only {{tags}} allowed, no free text"
      }
    },
    "canOnlyReplaceDynamicContent": {
      "description": "Only allow replacing existing dynamic content",
      "valueFormat": {
        "structure": "boolean",
        "notes": "When true, users cannot add NEW dynamic content tags, only replace/edit existing ones. Useful for locked templates where tag structure is fixed but tag selection can change. Example: pre-defined email template where placeholders exist but sender can swap which attributes fill them.",
        "typescript": "boolean",
        "example": "can-only-replace-dynamic-content // Edit existing tags only"
      }
    },
    "tipStatus": {
      "description": "Show usage tips",
      "valueFormat": {
        "structure": "boolean",
        "notes": "Displays helpful usage tips/hints to users within the editor interface. Tips can explain keyboard shortcuts, formatting syntax (WhatsApp *bold*), or dynamic content usage. Use slot 'tipOptions' to provide custom tip content. Helpful for first-time users or complex features.",
        "typescript": "boolean",
        "example": "tip-status // Shows usage tips in UI"
      }
    },
    "specialCharacters": {
      "description": "Special characters configuration",
      "valueFormat": {
        "structure": "Object with character settings",
        "notes": "Configures special character support (©, ®, ™, etc). When enabled=true, shows special character picker. Provide optional 'list' array to customize available characters. Useful for legal/marketing content requiring trademark symbols. Characters can be highlighted with isHighlightCharactersEnabled.",
        "typescript": "{ enabled: boolean; list?: string[]; }",
        "example": ":special-characters=\"{ enabled: true, list: ['©', '®', '™'] }\""
      }
    },
    "isHighlightCharactersEnabled": {
      "description": "Highlight special characters in text",
      "valueFormat": {
        "structure": "boolean",
        "notes": "When true, visually highlights special characters (from specialCharacters.list) in the editor. Helps users identify non-standard characters that might cause encoding issues in SMS or affect character count. Essential for multi-language or SMS campaigns where special chars consume extra space.",
        "typescript": "boolean",
        "example": "is-highlight-characters-enabled"
      }
    },
    "isHighlightUrlEnabled": {
      "description": "Highlight URLs in text",
      "valueFormat": {
        "structure": "boolean",
        "notes": "Automatically detects and highlights URLs in the text content. URLs become clickable and visually distinct. Detection uses urlPatternRegex if provided. Useful for email/SMS editors where link tracking or shortening is needed. Combine with @onShortenUrlClick event for URL shortening workflows.",
        "typescript": "boolean",
        "example": "is-highlight-url-enabled"
      }
    },
    "whatsappStylingSupport": {
      "description": "Enable WhatsApp text formatting (*bold*, _italic_)",
      "valueFormat": {
        "structure": "boolean",
        "notes": "Enables WhatsApp markdown-style formatting: *bold*, _italic_, ~strikethrough~, ```monospace```. When enabled, text wrapped in these symbols will be formatted in WhatsApp messages. Critical for WhatsApp Business API campaigns where formatting must match WhatsApp's syntax. Shows formatting hints to users.",
        "typescript": "boolean",
        "example": "whatsapp-styling-support // Enables *bold*, _italic_ syntax"
      }
    },
    "emojiButtonStatus": {
      "description": "Show emoji picker button - replaces V1 hasEmoji",
      "valueFormat": {
        "structure": "boolean",
        "notes": "Shows emoji picker button in toolbar. Replaces V1's hasEmoji prop. When clicked, opens emoji selector allowing users to insert emojis into content. Essential for social media posts, WhatsApp messages, or casual communication channels. Emojis can affect character count in SMS.",
        "typescript": "boolean",
        "example": "emoji-button-status // Shows emoji picker in toolbar"
      }
    },
    "isExtendedDynamicContent": {
      "description": "Enable extended dynamic content features",
      "valueFormat": {
        "structure": "boolean",
        "notes": "Enables advanced dynamic content features like nested attributes, conditional rendering, or complex data structures. When true, dynamic content picker shows extended UI with more options. Use dynamicContentBoxProps to configure the extended picker. For enterprise-level templating with complex data models.",
        "typescript": "boolean",
        "example": "is-extended-dynamic-content"
      }
    },
    "dynamicContentBoxProps": {
      "description": "Props for dynamic content selection box",
      "valueFormat": {
        "structure": "Object with box configuration",
        "notes": "Configuration for the dynamic content selection dropdown/modal. searchable=true adds search box (use when >20 attributes), grouped=true shows category groups, maxHeight limits dropdown height. Essential for large attribute lists to maintain usability. Works with isExtendedDynamicContent for advanced features.",
        "typescript": "{ searchable?: boolean; grouped?: boolean; maxHeight?: number; }",
        "example": ":dynamic-content-box-props=\"{ searchable: true, grouped: true }\""
      }
    },
    "usedDynamicContent": {
      "description": "Track which dynamic content is used",
      "valueFormat": {
        "structure": "Array of used attribute values",
        "notes": "Array tracking which dynamic content tags are currently in the message. Updates automatically as tags are added/removed. Use to show 'used attributes' list in UI, validate required attributes are present, or analyze attribute usage patterns. Emitted via @markedTags event.",
        "typescript": "Array<string>",
        "example": ":used-dynamic-content=\"['first_name', 'email']\" // Currently used tags"
      }
    },
    "errorTags": {
      "description": "Tags to highlight as errors",
      "valueFormat": {
        "structure": "Array of tag values",
        "notes": "Array of attribute values to mark as errors in the editor. Tags in this list will be visually highlighted with error styling. Use for invalid/undefined attributes, deprecated fields, or tags that failed validation. Critical for preventing message delivery failures from bad attribute references.",
        "typescript": "Array<string>",
        "example": ":error-tags=\"['invalid_attr', 'deleted_field']\" // Show as errors"
      }
    },
    "warningTags": {
      "description": "Tags to highlight as warnings",
      "valueFormat": {
        "structure": "Array of tag values",
        "notes": "Array of attribute values to mark with warning styling. Use for deprecated but still functional attributes, optional fields that might be empty, or attributes with potential issues. Warns users without blocking submission. Softer than errorTags.",
        "typescript": "Array<string>",
        "example": ":warning-tags=\"['deprecated_attr', 'beta_field']\" // Show warnings"
      }
    },
    "customCounter": {
      "description": "Custom counter component/logic",
      "valueFormat": {
        "structure": "Object or component",
        "notes": "Custom character counting logic or component to replace default counter. Use when standard counting doesn't fit your needs (e.g., Unicode normalization, special character weighting, GSM-7 encoding for SMS). Provide component or config object with counting function.",
        "typescript": "Object | Component",
        "example": ":custom-counter=\"smsGsmCounter\" // Custom SMS character counter"
      }
    },
    "footerLabel": {
      "description": "Label text in footer",
      "valueFormat": {
        "structure": "string",
        "notes": "Custom label text displayed in the editor footer. Appears when footerOptions includes 'label'. Use to provide context-specific information: 'SMS segments used', 'Characters remaining', 'Estimated send cost'. Shown alongside counter if both are enabled.",
        "typescript": "string",
        "example": "footer-label=\"SMS segments\""
      }
    },
    "urlPatternRegex": {
      "description": "Custom regex for URL detection",
      "valueFormat": {
        "structure": "RegExp",
        "notes": "Custom regular expression for detecting URLs in text. Default regex catches http/https URLs. Override to match custom URL formats, internal links, or specific domains. Used with isHighlightUrlEnabled to identify clickable links. Affects URL shortening and tracking features.",
        "typescript": "RegExp",
        "example": ":url-pattern-regex=\"/https?:\\/\\/[^\\s]+/g\""
      }
    },
    "isUploadFallback": {
      "description": "Enable image upload for fallback",
      "valueFormat": {
        "structure": "boolean",
        "notes": "Allows uploading images as fallback values for dynamic content. When user clicks on a dynamic tag, they can upload an image instead of text. Useful for personalized product images, profile pictures, or visual content in templates. Image URLs become fallback values.",
        "typescript": "boolean",
        "example": "is-upload-fallback // Allow image uploads for fallbacks"
      }
    },
    "fallbackVisibility": {
      "description": "Control fallback UI visibility",
      "valueFormat": {
        "structure": "string enum",
        "notes": "Controls when fallback editor UI is shown. 'always' shows fallback input permanently, 'onHover' reveals it when hovering over dynamic tags, 'onClick' shows modal when tag is clicked. Choose based on UX: onClick is cleaner for many tags, always is better for visibility.",
        "typescript": "'always' | 'onHover' | 'onClick'",
        "possibleValues": [
          "always",
          "onHover",
          "onClick"
        ],
        "example": "fallback-visibility=\"onHover\""
      }
    },
    "disabledToolbarOptions": {
      "description": "Disable specific toolbar buttons",
      "valueFormat": {
        "structure": "Array of option strings",
        "notes": "Array of toolbar button names to disable (greyed out, not clickable). Use to restrict certain formatting based on context: disable 'link' for SMS, disable 'emoji' for formal emails. More granular than omitting from toolbarOptions - buttons still visible but disabled.",
        "typescript": "Array<string>",
        "example": ":disabled-toolbar-options=\"['link', 'emoji']\" // Show but disable"
      }
    },
    "dynamicContentStates": {
      "description": "State configuration for dynamic content tags",
      "valueFormat": {
        "structure": "Object mapping tags to states",
        "notes": "Maps each dynamic content tag to a visual state (default/warning/error). More flexible than errorTags/warningTags arrays. Use for per-tag validation states: show 'email' as warning if optional, 'deleted_field' as error. State affects tag styling in editor.",
        "typescript": "Record<string, 'default' | 'warning' | 'error'>",
        "example": ":dynamic-content-states=\"{ 'old_attr': 'warning', 'invalid': 'error' }\""
      }
    }
  },
  "eventEnrichments": {
    "purify": {
      "description": "Emitted with sanitized string content",
      "payload": "string",
      "usage": "@purify=\"handlePurify\""
    },
    "purifyObject": {
      "description": "Emitted with detailed purified content object",
      "payload": "{ text: string, html: string, tags: Array }",
      "usage": "@purify-object=\"handlePurifyObject\""
    },
    "generate": {
      "description": "Emitted when content is generated/composed",
      "payload": "string",
      "usage": "@generate=\"handleGenerate\""
    },
    "markedTags": {
      "description": "Emitted with list of used tags",
      "payload": "Array<string>",
      "usage": "@marked-tags=\"handleMarkedTags\""
    },
    "updateFallBackOptions": {
      "description": "Emitted when fallback options change",
      "payload": "Object - fallback configuration",
      "usage": "@update-fall-back-options=\"handleFallbackUpdate\""
    },
    "saveFallBackOption": {
      "description": "Emitted when fallback is saved",
      "payload": "{ tag: string, value: string }",
      "usage": "@save-fall-back-option=\"handleSaveFallback\""
    },
    "addDynamicAttribute": {
      "description": "Emitted when new dynamic attribute is added",
      "payload": "{ label: string, value: string }",
      "usage": "@add-dynamic-attribute=\"handleAddAttribute\""
    },
    "onShortenUrlClick": {
      "description": "Emitted when URL shortening is requested",
      "payload": "string - URL to shorten",
      "usage": "@on-shorten-url-click=\"handleShortenUrl\""
    },
    "closeAllEmojiPickers": {
      "description": "Emitted to close all emoji pickers",
      "payload": "void",
      "usage": "@close-all-emoji-pickers=\"handleCloseEmoji\""
    }
  },
  "examples": [
    {
      "title": "Basic Rich Text Editor",
      "description": "Simple editor with toolbar and dynamic content",
      "code": "<InRichTextInput\n  id=\"message\"\n  label-status\n  label-text=\"Message Content\"\n  placeholder-text=\"Enter your message...\"\n  v-model=\"content\"\n  :dynamic-content-list=\"[\n    { label: 'First Name', value: 'first_name', category: 'User' },\n    { label: 'Email', value: 'email', category: 'User' }\n  ]\"\n  :toolbar-options=\"['bold', 'italic', 'link', 'emoji', 'dynamicContent']\"\n  :footer-options=\"['counter']\"\n  character-counter-status\n  @purify=\"handlePurify\"\n/>"
    },
    {
      "title": "SMS Editor with Validation",
      "description": "SMS message editor with character limits",
      "code": "<InRichTextInput\n  id=\"sms\"\n  label-status\n  label-text=\"SMS Message\"\n  v-model=\"smsContent\"\n  :dynamic-content-list=\"attributes\"\n  helper-text-validation-config-status\n  :helper-text-validation-config=\"{ maxLength: 160, segmentLength: 160 }\"\n  character-counter-status\n  :footer-options=\"['counter', 'tags']\"\n  :max-selectable-dynamic-content=\"5\"\n  states=\"warning\"\n  state-message=\"Message will be split into multiple segments\"\n  @purify=\"handlePurify\"\n  @marked-tags=\"handleTags\"\n/>"
    },
    {
      "title": "WhatsApp Message Editor",
      "description": "Editor with WhatsApp formatting support",
      "code": "<InRichTextInput\n  id=\"whatsapp\"\n  label-status\n  label-text=\"WhatsApp Message\"\n  v-model=\"waContent\"\n  :dynamic-content-list=\"attributes\"\n  whatsapp-styling-support\n  emoji-button-status\n  is-highlight-url-enabled\n  :toolbar-options=\"['bold', 'italic', 'emoji', 'dynamicContent']\"\n  tip-status\n  @purify=\"handlePurify\"\n/>"
    },
    {
      "title": "Advanced Editor with Fallbacks",
      "description": "Full-featured editor with fallback handling",
      "code": "<InRichTextInput\n  id=\"email\"\n  label-status\n  label-text=\"Email Content\"\n  v-model=\"emailContent\"\n  :dynamic-content-list=\"attributes\"\n  is-extended-dynamic-content\n  :dynamic-content-box-props=\"{ searchable: true, grouped: true }\"\n  fall-back-label=\"Default Value\"\n  fall-back-placeholder=\"Enter default...\"\n  is-upload-fallback\n  fallback-visibility=\"onHover\"\n  :error-tags=\"invalidAttributes\"\n  :warning-tags=\"deprecatedAttributes\"\n  @purify-object=\"handlePurifyObject\"\n  @save-fall-back-option=\"handleSaveFallback\"\n  @add-dynamic-attribute=\"handleAddAttribute\"\n/>"
    }
  ],
  "commonMistakes": [
    {
      "mistake": "Using attributeList instead of dynamicContentList",
      "issue": "No dynamic content available",
      "solution": "V2 uses dynamic-content-list, not attribute-list",
      "severity": "high"
    },
    {
      "mistake": "Using textValidateConfig instead of helperTextValidationConfig",
      "issue": "Validation not working",
      "solution": "Use helper-text-validation-config with helper-text-validation-config-status",
      "severity": "high"
    },
    {
      "mistake": "Using invalid/warning booleans",
      "issue": "Validation state not shown",
      "solution": "Use states=\"error\" or states=\"warning\" with state-message",
      "severity": "high"
    },
    {
      "mistake": "Using isCounter instead of characterCounterStatus",
      "issue": "Counter not displayed",
      "solution": "Use character-counter-status",
      "severity": "medium"
    },
    {
      "mistake": "Using hasEmoji instead of emojiButtonStatus",
      "issue": "Emoji picker not shown",
      "solution": "Use emoji-button-status",
      "severity": "medium"
    },
    {
      "mistake": "Not handling @purify event",
      "issue": "Using raw unsanitized content",
      "solution": "Always use @purify or @purify-object for final content",
      "severity": "high"
    }
  ],
  "bestPractices": [
    {
      "practice": "Use toolbarOptions to control available features",
      "description": "Only show relevant toolbar buttons for the use case",
      "example": ":toolbar-options=\"['bold', 'italic', 'dynamicContent']\" for SMS"
    },
    {
      "practice": "Implement proper fallback handling",
      "description": "Use @save-fall-back-option to persist fallback values",
      "example": "@save-fall-back-option=\"persistFallback\""
    },
    {
      "practice": "Use dynamicContentStates for tag validation",
      "description": "Mark deprecated or invalid tags with visual feedback",
      "example": ":dynamic-content-states=\"{ 'old_field': 'warning' }\""
    },
    {
      "practice": "Enable helperTextValidationConfigStatus for limits",
      "description": "Show users validation feedback in real-time",
      "example": "helper-text-validation-config-status :helper-text-validation-config=\"{ maxLength: 160 }\""
    }
  ],
  "codeSnippets": {
    "basicRichText": {
      "title": "Basic Rich Text Editor",
      "description": "Simple editor with formatting toolbar",
      "code": "<script setup>\nimport { ref } from 'vue';\nimport { InRichTextInput } from '@useinsider/design-system-vue';\n\nconst content = ref('');\n</script>\n\n<template>\n  <InRichTextInput\n    id=\"editor\"\n    name=\"editor\"\n    v-model=\"content\"\n    label-text=\"Description\"\n    placeholder=\"Enter description...\"\n  />\n</template>"
    },
    "withMergeTags": {
      "title": "Rich Text with Merge Tags",
      "description": "Editor with dynamic content/personalization",
      "code": "<script setup>\nimport { ref } from 'vue';\n\nconst emailContent = ref('');\n\nconst mergeTags = [\n  { id: 'first_name', text: 'First Name', value: '{{first_name}}' },\n  { id: 'last_name', text: 'Last Name', value: '{{last_name}}' },\n  { id: 'email', text: 'Email', value: '{{email}}' },\n  { id: 'company', text: 'Company', value: '{{company}}' }\n];\n\nconst handlePurify = (cleanHtml) => {\n  console.log('Sanitized HTML:', cleanHtml);\n};\n</script>\n\n<template>\n  <InRichTextInput\n    id=\"email-editor\"\n    name=\"email-editor\"\n    v-model=\"emailContent\"\n    label-text=\"Email Content\"\n    dynamic-content-status\n    :dynamic-content-list=\"mergeTags\"\n    @purify=\"handlePurify\"\n  />\n</template>"
    },
    "withValidation": {
      "title": "Rich Text with Character Limit",
      "description": "Editor with validation and helper text",
      "code": "<script setup>\nimport { ref, computed } from 'vue';\n\nconst content = ref('');\nconst maxLength = 500;\n\nconst state = computed(() => {\n  const length = content.value.replace(/<[^>]*>/g, '').length;\n  if (length === 0) return 'error';\n  if (length > maxLength) return 'error';\n  if (length > maxLength * 0.9) return 'warning';\n  return 'default';\n});\n\nconst helperText = computed(() => {\n  const length = content.value.replace(/<[^>]*>/g, '').length;\n  return `${length}/${maxLength} characters`;\n});\n</script>\n\n<template>\n  <InRichTextInput\n    id=\"limited-editor\"\n    name=\"limited-editor\"\n    v-model=\"content\"\n    label-text=\"Short Description\"\n    :state=\"state\"\n    :helper-text=\"helperText\"\n    helper-text-validation-config-status\n    :helper-text-validation-config=\"{ maxLength }\"\n  />\n</template>"
    }
  },
  "styling": {
    "cssVariables": {
      "--rich-text-bg": "Editor background (default: white)",
      "--rich-text-text": "Text color",
      "--rich-text-border": "Border color",
      "--rich-text-toolbar-bg": "Toolbar background",
      "--rich-text-button-hover": "Toolbar button hover color",
      "--rich-text-placeholder": "Placeholder text color"
    },
    "classes": {
      "in-rich-text-input": "Root container",
      "in-rich-text-input__toolbar": "Formatting toolbar",
      "in-rich-text-input__editor": "Editable content area",
      "in-rich-text-input__button": "Toolbar button",
      "in-rich-text-input__button--active": "Active format button",
      "in-rich-text-input__merge-tag": "Inserted merge tag",
      "in-rich-text-input__helper": "Helper text below editor",
      "in-rich-text-input__counter": "Character counter"
    },
    "notes": "Rich text editor supports HTML formatting. Merge tags styled differently for visibility."
  },
  "implementationPatterns": [
    {
      "name": "Email Template Editor",
      "description": "Rich text editor for email templates with personalization",
      "code": "<script setup>\nimport { ref } from 'vue';\nimport { InRichTextInput } from '@useinsider/design-system-vue';\n\nconst emailTemplate = ref('');\n\nconst customerFields = [\n  { id: 'first_name', text: 'First Name', value: '{{first_name}}' },\n  { id: 'last_name', text: 'Last Name', value: '{{last_name}}' },\n  { id: 'email', text: 'Email Address', value: '{{email}}' },\n  { id: 'phone', text: 'Phone Number', value: '{{phone}}' },\n  { id: 'company', text: 'Company Name', value: '{{company}}' },\n  { id: 'order_id', text: 'Order ID', value: '{{order_id}}' }\n];\n\nconst dynamicContentBoxProps = {\n  searchable: true,\n  grouped: true,\n  groups: {\n    'Customer': ['first_name', 'last_name', 'email', 'phone'],\n    'Business': ['company', 'order_id']\n  }\n};\n\nconst handleSave = async () => {\n  const response = await fetch('/api/email-templates', {\n    method: 'POST',\n    body: JSON.stringify({\n      content: emailTemplate.value\n    })\n  });\n};\n</script>\n\n<template>\n  <InRichTextInput\n    id=\"email-template\"\n    name=\"email-template\"\n    v-model=\"emailTemplate\"\n    label-text=\"Email Template\"\n    dynamic-content-status\n    :dynamic-content-list=\"customerFields\"\n    :dynamic-content-box-props=\"dynamicContentBoxProps\"\n    dynamic-content-box-label=\"Insert Customer Field\"\n  />\n</template>",
      "when": "Building email marketing or notification systems",
      "pros": ["Personalization support", "Rich formatting", "Template reusability"],
      "cons": ["Complex state management", "HTML sanitization needed"]
    },
    {
      "name": "Blog Post Editor",
      "description": "Content editor for blog posts with media",
      "code": "<script setup>\nimport { ref } from 'vue';\nimport { InRichTextInput } from '@useinsider/design-system-vue';\n\nconst postContent = ref('');\nconst isDraft = ref(true);\n\nconst toolbarConfig = {\n  bold: true,\n  italic: true,\n  underline: true,\n  heading: true,\n  bulletList: true,\n  orderedList: true,\n  link: true,\n  image: true,\n  code: true\n};\n\nconst autoSave = async () => {\n  if (!isDraft.value) return;\n  \n  await fetch('/api/posts/autosave', {\n    method: 'POST',\n    body: JSON.stringify({\n      content: postContent.value,\n      timestamp: Date.now()\n    })\n  });\n};\n\n// Auto-save every 30 seconds\nsetInterval(autoSave, 30000);\n</script>\n\n<template>\n  <InRichTextInput\n    id=\"blog-editor\"\n    name=\"blog-editor\"\n    v-model=\"postContent\"\n    label-text=\"Post Content\"\n    placeholder=\"Write your blog post...\"\n    :toolbar=\"toolbarConfig\"\n  />\n</template>",
      "when": "Building CMS or blogging platforms",
      "pros": ["Full formatting control", "Auto-save capability", "Media embedding"],
      "cons": ["Large payloads", "Complex content validation"]
    },
    {
      "name": "SMS Message Editor",
      "description": "Character-limited editor for SMS with merge tags",
      "code": "<script setup>\nimport { ref, computed } from 'vue';\nimport { InRichTextInput } from '@useinsider/design-system-vue';\n\nconst smsContent = ref('');\nconst maxChars = 160;\n\nconst mergeTags = [\n  { id: 'name', text: 'Name', value: '{{name}}' },\n  { id: 'code', text: 'Verification Code', value: '{{code}}' },\n  { id: 'link', text: 'Link', value: '{{link}}' }\n];\n\nconst charCount = computed(() => {\n  // Remove HTML tags and count merge tags as their max length\n  let text = smsContent.value.replace(/<[^>]*>/g, '');\n  text = text.replace(/{{name}}/g, 'X'.repeat(50));\n  text = text.replace(/{{code}}/g, 'X'.repeat(6));\n  text = text.replace(/{{link}}/g, 'X'.repeat(100));\n  return text.length;\n});\n\nconst state = computed(() => {\n  if (charCount.value > maxChars) return 'error';\n  if (charCount.value > maxChars * 0.9) return 'warning';\n  return 'default';\n});\n\nconst helperText = computed(() => {\n  const remaining = maxChars - charCount.value;\n  if (remaining < 0) return `Over limit by ${Math.abs(remaining)} characters`;\n  return `${remaining} characters remaining`;\n});\n</script>\n\n<template>\n  <InRichTextInput\n    id=\"sms-editor\"\n    name=\"sms-editor\"\n    v-model=\"smsContent\"\n    label-text=\"SMS Message\"\n    dynamic-content-status\n    :dynamic-content-list=\"mergeTags\"\n    :state=\"state\"\n    :helper-text=\"helperText\"\n    :toolbar=\"{ bold: false, italic: false, link: false }\"\n  />\n</template>",
      "when": "Building SMS marketing or notification systems",
      "pros": ["Character counting", "Merge tag support", "Length validation"],
      "cons": ["Complex character calculation", "Limited formatting"]
    }
  ],
  "useCases": [
    {
      "title": "Email Marketing",
      "description": "Rich email templates with personalization",
      "example": "<InRichTextInput\n  label-text=\"Email Content\"\n  dynamic-content-status\n  :dynamic-content-list=\"customerFields\"\n  v-model=\"emailContent\"\n/>"
    },
    {
      "title": "Blog Content",
      "description": "Blog post editor with full formatting",
      "example": "<InRichTextInput\n  label-text=\"Post Content\"\n  v-model=\"postContent\"\n  :toolbar=\"fullToolbar\"\n/>"
    },
    {
      "title": "Product Descriptions",
      "description": "Rich product descriptions with character limits",
      "example": "<InRichTextInput\n  label-text=\"Description\"\n  v-model=\"description\"\n  :helper-text-validation-config=\"{ maxLength: 500 }\"\n  helper-text-validation-config-status\n/>"
    },
    {
      "title": "Notification Messages",
      "description": "Push/SMS messages with merge tags",
      "example": "<InRichTextInput\n  label-text=\"Message\"\n  dynamic-content-status\n  :dynamic-content-list=\"mergeTags\"\n  v-model=\"message\"\n/>"
    }
  ],
  "accessibilityNotes": [
    {
      "topic": "Label requirement",
      "description": "Rich text editor must have descriptive label",
      "wcagLevel": "A",
      "recommendation": "Always provide label-text prop",
      "example": "<InRichTextInput label-text=\"Email Content\" />"
    },
    {
      "topic": "Toolbar button labels",
      "description": "Formatting buttons need accessible labels",
      "wcagLevel": "A",
      "recommendation": "Component provides ARIA labels for all toolbar buttons",
      "example": "// Bold button has aria-label=\"Bold\""
    },
    {
      "topic": "Keyboard shortcuts",
      "description": "Editor must support keyboard shortcuts",
      "wcagLevel": "AA",
      "recommendation": "Ctrl+B (bold), Ctrl+I (italic), Ctrl+U (underline), etc.",
      "example": "// Automatically supported by component"
    },
    {
      "topic": "Merge tag accessibility",
      "description": "Dynamic content tags must be announced",
      "wcagLevel": "AA",
      "recommendation": "Use aria-label to describe merge tag purpose",
      "example": "// Merge tag announced as 'First Name merge tag'"
    }
  ],
  "helperFunctions": [
    {
      "name": "stripHtmlTags",
      "description": "Remove HTML tags to get plain text for character counting",
      "code": "function stripHtmlTags(html: string): string {\n  return html.replace(/<[^>]*>/g, '');\n}",
      "parameters": [
        {
          "name": "html",
          "type": "string",
          "description": "HTML content"
        }
      ],
      "returnType": "string",
      "example": "const plainText = stripHtmlTags('<p>Hello <b>World</b></p>');\n// Returns: 'Hello World'"
    },
    {
      "name": "calculateMergeTagLength",
      "description": "Calculate estimated length with expanded merge tags",
      "code": "function calculateMergeTagLength(content: string, tagLengths: Record<string, number>): number {\n  let text = content.replace(/<[^>]*>/g, '');\n  \n  Object.entries(tagLengths).forEach(([tag, length]) => {\n    const regex = new RegExp(`{{${tag}}}`, 'g');\n    text = text.replace(regex, 'X'.repeat(length));\n  });\n  \n  return text.length;\n}",
      "parameters": [
        {
          "name": "content",
          "type": "string",
          "description": "Rich text content with merge tags"
        },
        {
          "name": "tagLengths",
          "type": "Record<string, number>",
          "description": "Max length for each merge tag"
        }
      ],
      "returnType": "number",
      "example": "const length = calculateMergeTagLength(\n  'Hello {{name}}',\n  { name: 50 }\n);\n// Returns: 56 (Hello  + 50 chars)"
    },
    {
      "name": "sanitizeRichText",
      "description": "Sanitize HTML while preserving allowed tags",
      "code": "function sanitizeRichText(html: string, allowedTags: string[] = ['p', 'b', 'i', 'u', 'a', 'br']): string {\n  const div = document.createElement('div');\n  div.innerHTML = html;\n  \n  const walk = (node: Node) => {\n    if (node.nodeType === 1) { // Element node\n      const tagName = (node as Element).tagName.toLowerCase();\n      if (!allowedTags.includes(tagName)) {\n        // Replace with text content\n        const textNode = document.createTextNode(node.textContent || '');\n        node.parentNode?.replaceChild(textNode, node);\n      }\n    }\n    \n    node.childNodes.forEach(walk);\n  };\n  \n  walk(div);\n  return div.innerHTML;\n}",
      "parameters": [
        {
          "name": "html",
          "type": "string",
          "description": "HTML content to sanitize"
        },
        {
          "name": "allowedTags",
          "type": "string[]",
          "description": "Array of allowed HTML tags"
        }
      ],
      "returnType": "string",
      "example": "const clean = sanitizeRichText(\n  '<p>Hello <script>alert(1)</script></p>',\n  ['p', 'b', 'i']\n);\n// Returns: '<p>Hello alert(1)</p>'"
    }
  ],
  "performanceNotes": [
    {
      "topic": "Large dynamic content lists",
      "description": "Large dynamicContentList (50+ items) can slow dropdown rendering",
      "recommendation": "Use dynamicContentBoxProps.searchable for large lists, enable search when > 20 attributes",
      "impact": "medium"
    },
    {
      "topic": "Frequent purify events",
      "description": "purify event fires on every content change",
      "recommendation": "Debounce expensive operations in purify handler if doing API calls or complex processing",
      "impact": "low"
    },
    {
      "topic": "HTML content size",
      "description": "Rich HTML content can become very large",
      "recommendation": "Implement content compression for storage, consider plain text fallback",
      "impact": "medium"
    }
  ],
  "commonMistakes": [
    {
      "mistake": "Not sanitizing HTML output before saving",
      "why": "User input can contain malicious scripts",
      "impact": "XSS vulnerability, security risk",
      "fix": "Use @purify event or sanitize before saving to database",
      "severity": "critical",
      "example": "// Listen to purify event:\n@purify=\"handleSanitized\"\n\nconst handleSanitized = (cleanHtml) => {\n  // Save cleanHtml to database\n}"
    },
    {
      "mistake": "Incorrect character counting with HTML tags",
      "why": "HTML tags inflate character count",
      "impact": "Inaccurate length validation",
      "fix": "Strip HTML tags before counting: content.replace(/<[^>]*>/g, '')",
      "severity": "high",
      "example": "// Wrong:\nconst count = content.value.length;\n\n// Correct:\nconst count = content.value.replace(/<[^>]*>/g, '').length;"
    },
    {
      "mistake": "Not handling merge tag max lengths",
      "why": "Merge tags expand to variable-length values",
      "impact": "Content exceeds limits when tags are replaced",
      "fix": "Calculate with max expected length for each tag",
      "severity": "medium",
      "example": "// Replace {{name}} with max length estimate\nconst estimated = text.replace(/{{name}}/g, 'X'.repeat(50));"
    }
  ],
  "bestPractices": [
    {
      "title": "Always Handle Purify Event",
      "description": "Sanitize HTML content before saving",
      "code": "<InRichTextInput\n  v-model=\"content\"\n  @purify=\"handleSanitized\"\n/>\n\nconst handleSanitized = (cleanHtml) => {\n  // Save cleanHtml to database\n  saveContent(cleanHtml);\n};",
      "reasoning": "Prevents XSS attacks and ensures clean HTML"
    },
    {
      "title": "Group Merge Tags Logically",
      "description": "Use dynamicContentBoxProps.groups for better UX",
      "code": "const dynamicContentBoxProps = {\n  searchable: true,\n  grouped: true,\n  groups: {\n    'Customer Info': ['name', 'email', 'phone'],\n    'Order Details': ['order_id', 'total', 'status']\n  }\n};",
      "reasoning": "Makes it easier for users to find relevant merge tags"
    },
    {
      "title": "Implement Character Limits",
      "description": "Use helper text validation for length constraints",
      "code": "<InRichTextInput\n  helper-text-validation-config-status\n  :helper-text-validation-config=\"{ maxLength: 500 }\"\n  :helper-text=\"charCountMessage\"\n/>",
      "reasoning": "Prevents content from exceeding platform limits (SMS, push, etc.)"
    }
  ]
}
