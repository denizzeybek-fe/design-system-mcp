{
  "component": "InDatePickerV2",
  "_metadata": {
    "lastUpdated": "2025-11-25T14:48:39.823Z",
    "propsHash": "29c197a84335",
    "eventsHash": "7db6af6c4a11",
    "propCount": 41,
    "eventCount": 7
  },
  "propEnrichments": {
    "value": {
      "valueFormat": {
        "structure": "Array<{ startDate: string, endDate: string }>",
        "examples": [
          "[{ startDate: '01.12.2024', endDate: '20.12.2024' }]",
          "[{ startDate: '01.12.2024', endDate: '20.12.2024' }, { startDate: '01.11.2024', endDate: '20.11.2024' }]"
        ],
        "notes": "CRITICAL: Always pass an array of objects, even for single range. Second object is optional and used for comparison mode. Date format depends on locale (dd.mm.yyyy or mm/dd/yyyy).",
        "typescript": "Array<{ startDate: string; endDate: string }>"
      },
      "relatedProps": [
        "comparisonStatus",
        "singleDatePickerStatus",
        "locale",
        "formatMapping"
      ],
      "commonMistakes": [
        {
          "mistake": "Passing value as array of strings: [startDate, endDate]",
          "impact": "Component won't display selected dates, renders empty",
          "fix": "Wrap in object: [{ startDate, endDate }]",
          "severity": "critical"
        },
        {
          "mistake": "Not wrapping single range in array",
          "impact": "Type error, component may crash",
          "fix": "Always use array: [{ startDate, endDate }]",
          "severity": "critical"
        }
      ]
    },
    "customRanges": {
      "valueFormat": {
        "structure": "Array<{ name: string, title: string, startDate: string, endDate: string }>",
        "examples": [
          "[{ name: 'custom1', title: 'Q4 2024', startDate: '10/01/2024', endDate: '12/31/2024' }]",
          "[{ name: 'custom1', title: 'Last Quarter', startDate: '09/01/2024', endDate: '11/30/2024' }, { name: 'custom2', title: 'This Year', startDate: '01/01/2024', endDate: '12/31/2024' }]"
        ],
        "notes": "CRITICAL: Date format MUST be mm/dd/yyyy with SLASH delimiter, regardless of locale. 'name' must be unique identifier, 'title' is display text.",
        "typescript": "Array<{ name: string; title: string; startDate: string; endDate: string }>"
      },
      "relatedProps": [
        "comparedCustomRanges",
        "quickRangeSelectionStatus",
        "defaultRanges"
      ],
      "commonMistakes": [
        {
          "mistake": "Using 'label' property instead of 'title'",
          "impact": "Range buttons won't show text labels",
          "fix": "Change { label: 'Q4' } to { title: 'Q4' }",
          "severity": "high",
          "detectPattern": "customRanges.*label:"
        },
        {
          "mistake": "Using dd.mm.yyyy or dd/mm/yyyy format",
          "impact": "Date parsing fails, shows 'Invalid Date'",
          "fix": "Use mm/dd/yyyy format: '12/31/2024' not '31.12.2024'",
          "severity": "critical",
          "helperFunction": "formatDateToSlash"
        },
        {
          "mistake": "Passing Date objects instead of strings",
          "impact": "Type error, component won't render",
          "fix": "Convert to string: formatDateToSlash(new Date())",
          "severity": "critical",
          "helperFunction": "formatDateToSlash"
        },
        {
          "mistake": "Not providing unique 'name' property",
          "impact": "Range selection tracking fails",
          "fix": "Add unique name: { name: 'custom1', ... }",
          "severity": "medium"
        }
      ]
    },
    "comparedCustomRanges": {
      "valueFormat": {
        "structure": "Array<{ name: string, title: string, startDate: string, endDate: string }>",
        "examples": [
          "[{ name: 'lastYear', title: 'Previous Period Last Year', startDate: '09/18/2024', endDate: '10/19/2024' }]"
        ],
        "notes": "CRITICAL: Same format as customRanges. Often calculated dynamically based on main period selection using @periodSelected event.",
        "typescript": "Array<{ name: string; title: string; startDate: string; endDate: string }>"
      },
      "relatedProps": [
        "customRanges",
        "comparisonStatus"
      ],
      "commonMistakes": [
        {
          "mistake": "Not recalculating when main period changes",
          "impact": "Stale comparison ranges, confusing UX",
          "fix": "Watch @periodSelected event and recalculate",
          "severity": "medium",
          "pattern": "Dynamic calculation based on selected period"
        }
      ]
    },
    "comparisonStatus": {
      "valueFormat": {
        "structure": "boolean",
        "notes": "CRITICAL: Controls visibility of comparison toggle button, NOT the comparison state itself. Keep this TRUE if you want comparison feature available.",
        "typescript": "boolean"
      },
      "relatedProps": [
        "disabledComparisonStatus",
        "disabledComparisonTooltipText"
      ],
      "relatedEvents": [
        "openComparison",
        "closeComparison"
      ],
      "commonMistakes": [
        {
          "mistake": "Binding to reactive state: :comparison-status=\"isComparisonOpen\"",
          "impact": "Toggle button disappears when comparison is closed",
          "fix": "Use static :comparison-status=\"true\" and handle state with @openComparison/@closeComparison events",
          "severity": "critical",
          "correctPattern": ":comparison-status=\"true\" @openComparison=\"handleOpen\" @closeComparison=\"handleClose\""
        }
      ]
    },
    "quickRangeSelectionStatus": {
      "valueFormat": {
        "structure": "boolean",
        "notes": "Shows quick range buttons (Today, Yesterday, Last 7 Days, etc.). Often forgotten but crucial for UX.",
        "typescript": "boolean"
      },
      "relatedProps": [
        "defaultRanges",
        "customRanges"
      ],
      "commonMistakes": [
        {
          "mistake": "Forgetting to set this to true",
          "impact": "No quick range buttons shown, poor UX",
          "fix": "Add :quick-range-selection-status=\"true\"",
          "severity": "medium"
        }
      ]
    },
    "disabledRange": {
      "valueFormat": {
        "structure": "{ startDate: string, endDate: string }",
        "examples": [
          "{ startDate: '01.12.2024', endDate: '31.12.2024' }"
        ],
        "notes": "V1 used array of unix timestamps [start, end]. V2 uses object with date strings.",
        "typescript": "{ startDate: string; endDate: string }"
      },
      "migrationFromV1": {
        "v1Format": "Array [unixTimestampStart, unixTimestampEnd]",
        "v2Format": "Object { startDate: string, endDate: string }",
        "transformation": "{ startDate: formatDate(new Date(v1[0] * 1000)), endDate: formatDate(new Date(v1[1] * 1000)) }"
      },
      "commonMistakes": [
        {
          "mistake": "Using V1 array format",
          "impact": "Disabled range won't work",
          "fix": "Convert to object format",
          "severity": "high"
        }
      ]
    },
    "formatMapping": {
      "valueFormat": {
        "structure": "{ [locale: string]: string }",
        "examples": [
          "{ 'en-US': 'mm/dd/yyyy', 'en-GB': 'dd/mm/yyyy', 'tr-TR': 'dd.mm.yyyy', 'default': 'dd.mm.yyyy' }"
        ],
        "notes": "Maps locale codes to date format strings. Used for display formatting.",
        "typescript": "Record<string, string>"
      },
      "relatedProps": [
        "locale"
      ],
      "commonMistakes": []
    },
    "theme": {
      "valueFormat": {
        "structure": "'white' | 'grey'",
        "notes": "TODO: Add usage notes",
        "typescript": "'white' | 'grey'",
        "example": "TODO: Add example for white"
      },
      "possibleValues": [
        {
          "value": "white",
          "description": "TODO: Add description for 'white'"
        },
        {
          "value": "grey",
          "description": "TODO: Add description for 'grey'"
        }
      ]
    }
  },
  "eventEnrichments": {
    "apply": {
      "payloadTypes": [
        {
          "condition": "Single range (no comparison)",
          "type": "string",
          "format": "\"mm/dd/yyyy-mm/dd/yyyy\"",
          "example": "\"12/01/2024-12/20/2024\""
        },
        {
          "condition": "With comparison",
          "type": "Array<string>",
          "format": "[\"mm/dd/yyyy-mm/dd/yyyy\", \"mm/dd/yyyy-mm/dd/yyyy\"]",
          "example": "[\"12/01/2024-12/20/2024\", \"11/01/2024-11/20/2024\"]"
        }
      ],
      "handlingPattern": "if (Array.isArray(payload)) {\n  const [mainRange, comparisonRange] = payload;\n  this.$emit('apply-date-selection', mainRange);\n  this.$emit('apply-comparison-date-selection', comparisonRange);\n} else {\n  this.$emit('apply-date-selection', payload);\n}",
      "commonMistakes": [
        {
          "mistake": "Not handling both string and array formats",
          "impact": "Crashes when comparison is active",
          "fix": "Always check Array.isArray(payload) first",
          "severity": "critical"
        }
      ]
    },
    "periodSelected": {
      "payloadTypes": [
        {
          "condition": "Always",
          "type": "{ start: string, end: string }",
          "format": "{ start: 'dd.mm.yyyy', end: 'dd.mm.yyyy' }",
          "example": "{ start: '01.12.2024', end: '20.12.2024' }"
        }
      ],
      "useCase": "Triggered when user selects a main period. Use this to recalculate dynamic comparison ranges (e.g., Previous Period Last Year)",
      "handlingPattern": "handlePeriodSelected(range) {\n  const start = this.parseDate(range.start);\n  const end = this.parseDate(range.end);\n  const periodLength = Math.floor((end - start) / (1000 * 60 * 60 * 24)) + 1;\n  \n  // Calculate Previous Period\n  const prevEnd = new Date(start);\n  prevEnd.setDate(start.getDate() - 1);\n  const prevStart = new Date(prevEnd);\n  prevStart.setDate(prevEnd.getDate() - periodLength + 1);\n  \n  // Previous Period Last Year\n  const lastYearStart = new Date(prevStart);\n  lastYearStart.setFullYear(prevStart.getFullYear() - 1);\n  const lastYearEnd = new Date(prevEnd);\n  lastYearEnd.setFullYear(prevEnd.getFullYear() - 1);\n  \n  this.comparedCustomRangesForV2 = [{\n    name: 'lastYear',\n    title: 'Previous Period Last Year',\n    startDate: this.formatDateToSlash(lastYearStart),\n    endDate: this.formatDateToSlash(lastYearEnd)\n  }];\n}"
    },
    "comparisonPeriodSelected": {
      "payloadTypes": [
        {
          "condition": "Always",
          "type": "{ start: string, end: string }",
          "format": "{ start: 'dd.mm.yyyy', end: 'dd.mm.yyyy' }",
          "example": "{ start: '01.11.2024', end: '20.11.2024' }"
        }
      ],
      "useCase": "Triggered when user selects a comparison period"
    },
    "openComparison": {
      "payloadTypes": [
        {
          "condition": "Always",
          "type": "{ predefinedRange: object, comparedRange: object }",
          "format": "{ predefinedRange: { start, end }, comparedRange: { start, end } }",
          "example": "{ predefinedRange: { start: '01.12.2024', end: '20.12.2024' }, comparedRange: { start: '', end: '' } }"
        }
      ],
      "useCase": "Triggered when comparison toggle is activated",
      "handlingPattern": "handleOpenComparison() {\n  this.isComparisonActive = true;\n}"
    },
    "closeComparison": {
      "payloadTypes": [
        {
          "condition": "Always",
          "type": "{ predefinedRange: object, comparedRange: object }",
          "format": "{ predefinedRange: { start, end }, comparedRange: { start, end } }",
          "example": "{ predefinedRange: { start: '01.12.2024', end: '20.12.2024' }, comparedRange: { start: '', end: '' } }"
        }
      ],
      "useCase": "Triggered when comparison toggle is deactivated",
      "handlingPattern": "handleCloseComparison() {\n  this.isComparisonActive = false;\n  this.comparisonStartDate = '';\n  this.comparisonEndDate = '';\n}"
    }
  },
  "examples": [
    {
      "title": "Basic Date Range Picker",
      "description": "Simple date range picker without comparison",
      "complexity": "beginner",
      "code": "<template>\n  <InDatePickerV2\n    id=\"date-picker\"\n    name=\"date-picker\"\n    theme=\"white\"\n    label-text=\"Select Period\"\n    :value=\"dateValue\"\n    :min-date=\"minDate\"\n    :max-date=\"maxDate\"\n    :locale=\"locale\"\n    :format-mapping=\"formatMapping\"\n    :quick-range-selection-status=\"true\"\n    @apply=\"handleApply\" />\n</template>\n\n<script>\nimport { InDatePickerV2 } from '@useinsider/design-system-vue';\n\nexport default {\n  components: { InDatePickerV2 },\n  \n  data() {\n    return {\n      startDate: '01.12.2024',\n      endDate: '20.12.2024',\n      minDate: '01.01.2023',\n      maxDate: new Date(),\n      locale: 'tr-TR',\n      formatMapping: {\n        'tr-TR': 'dd.mm.yyyy',\n        'en-US': 'mm/dd/yyyy',\n        'default': 'dd.mm.yyyy'\n      }\n    };\n  },\n  \n  computed: {\n    dateValue() {\n      return [{\n        startDate: this.startDate,\n        endDate: this.endDate\n      }];\n    }\n  },\n  \n  methods: {\n    handleApply(payload) {\n      // payload is string: \"mm/dd/yyyy-mm/dd/yyyy\"\n      const [start, end] = payload.split('-');\n      this.startDate = this.convertToLocalFormat(start);\n      this.endDate = this.convertToLocalFormat(end);\n    },\n    \n    convertToLocalFormat(dateStr) {\n      // Convert mm/dd/yyyy to dd.mm.yyyy for Turkish locale\n      const [month, day, year] = dateStr.split('/');\n      return `${day}.${month}.${year}`;\n    }\n  }\n};\n</script>"
    },
    {
      "title": "With Comparison & Dynamic Ranges",
      "description": "Full-featured date picker with comparison mode and dynamically calculated comparison ranges",
      "complexity": "advanced",
      "code": "<template>\n  <InDatePickerV2\n    :key=\"`${datePickerKey}-${startDate}-${endDate}`\"\n    id=\"date-picker-compare\"\n    name=\"date-picker-compare\"\n    theme=\"white\"\n    label-text=\"Select Period\"\n    :value=\"datePickerValue\"\n    :min-date=\"minDate\"\n    :max-date=\"maxDate\"\n    :locale=\"locale\"\n    :format-mapping=\"formatMapping\"\n    :comparison-status=\"true\"\n    :disabled-comparison-status=\"compareDisabled\"\n    :quick-range-selection-status=\"true\"\n    :custom-ranges=\"customRangesForV2\"\n    :compared-custom-ranges=\"comparedCustomRangesForV2\"\n    @apply=\"handleApply\"\n    @periodSelected=\"handlePeriodSelected\"\n    @openComparison=\"handleOpenComparison\"\n    @closeComparison=\"handleCloseComparison\" />\n</template>\n\n<script>\nimport { InDatePickerV2 } from '@useinsider/design-system-vue';\n\nexport default {\n  components: { InDatePickerV2 },\n  \n  data() {\n    return {\n      datePickerKey: 0,\n      startDate: '01.12.2024',\n      endDate: '20.12.2024',\n      comparisonStartDate: '',\n      comparisonEndDate: '',\n      isComparisonActive: false,\n      compareDisabled: false,\n      comparedCustomRangesForV2: [],\n      minDate: '01.01.2023',\n      maxDate: new Date(),\n      locale: 'tr-TR',\n      formatMapping: {\n        'tr-TR': 'dd.mm.yyyy',\n        'en-US': 'mm/dd/yyyy',\n        'default': 'dd.mm.yyyy'\n      },\n      customDateRanges: {\n        'Q4 2024': [new Date('2024-10-01'), new Date('2024-12-31')],\n        'Last Quarter': [new Date('2024-07-01'), new Date('2024-09-30')]\n      }\n    };\n  },\n  \n  computed: {\n    datePickerValue() {\n      const main = {\n        startDate: this.startDate,\n        endDate: this.endDate\n      };\n      \n      if (this.isComparisonActive && this.comparisonStartDate && this.comparisonEndDate) {\n        return [\n          main,\n          {\n            startDate: this.comparisonStartDate,\n            endDate: this.comparisonEndDate\n          }\n        ];\n      }\n      \n      return [main];\n    },\n    \n    customRangesForV2() {\n      return Object.entries(this.customDateRanges).map(([title, dates], index) => ({\n        name: `custom${index + 1}`,\n        title,\n        startDate: this.formatDateToSlash(dates[0]),\n        endDate: this.formatDateToSlash(dates[1])\n      }));\n    }\n  },\n  \n  methods: {\n    handlePeriodSelected(range) {\n      // Recalculate dynamic comparison ranges\n      const start = this.parseDate(range.start);\n      const end = this.parseDate(range.end);\n      const periodLength = Math.floor((end - start) / (1000 * 60 * 60 * 24)) + 1;\n      \n      // Previous Period\n      const prevEnd = new Date(start);\n      prevEnd.setDate(start.getDate() - 1);\n      const prevStart = new Date(prevEnd);\n      prevStart.setDate(prevEnd.getDate() - periodLength + 1);\n      \n      // Previous Period Last Year\n      const lastYearStart = new Date(prevStart);\n      lastYearStart.setFullYear(prevStart.getFullYear() - 1);\n      const lastYearEnd = new Date(prevEnd);\n      lastYearEnd.setFullYear(prevEnd.getFullYear() - 1);\n      \n      this.comparedCustomRangesForV2 = [{\n        name: 'lastYear',\n        title: 'Previous Period Last Year',\n        startDate: this.formatDateToSlash(lastYearStart),\n        endDate: this.formatDateToSlash(lastYearEnd)\n      }];\n    },\n    \n    handleApply(payload) {\n      if (Array.isArray(payload)) {\n        // With comparison\n        const [mainRange, comparisonRange] = payload;\n        this.applyDateRange(mainRange);\n        this.applyComparisonRange(comparisonRange);\n      } else {\n        // Single range\n        this.applyDateRange(payload);\n      }\n    },\n    \n    applyDateRange(rangeStr) {\n      const [start, end] = rangeStr.split('-');\n      this.startDate = this.convertToLocalFormat(start);\n      this.endDate = this.convertToLocalFormat(end);\n    },\n    \n    applyComparisonRange(rangeStr) {\n      const [start, end] = rangeStr.split('-');\n      this.comparisonStartDate = this.convertToLocalFormat(start);\n      this.comparisonEndDate = this.convertToLocalFormat(end);\n    },\n    \n    handleOpenComparison() {\n      this.isComparisonActive = true;\n    },\n    \n    handleCloseComparison() {\n      this.isComparisonActive = false;\n      this.comparisonStartDate = '';\n      this.comparisonEndDate = '';\n    },\n    \n    formatDateToSlash(date) {\n      const d = new Date(date);\n      const month = String(d.getMonth() + 1).padStart(2, '0');\n      const day = String(d.getDate()).padStart(2, '0');\n      const year = d.getFullYear();\n      return `${month}/${day}/${year}`;\n    },\n    \n    parseDate(dateStr) {\n      const parts = dateStr.split(/[/.]/); \n      const isSlash = dateStr.includes('/');\n      \n      if (isSlash) {\n        // mm/dd/yyyy\n        const [month, day, year] = parts;\n        return new Date(parseInt(year), parseInt(month) - 1, parseInt(day));\n      } else {\n        // dd.mm.yyyy\n        const [day, month, year] = parts;\n        return new Date(parseInt(year), parseInt(month) - 1, parseInt(day));\n      }\n    },\n    \n    convertToLocalFormat(dateStr) {\n      const [month, day, year] = dateStr.split('/');\n      return `${day}.${month}.${year}`;\n    }\n  }\n};\n</script>"
    }
  ],
  "helperFunctions": [
    {
      "name": "formatDateToSlash",
      "description": "Convert Date object to mm/dd/yyyy format (required for customRanges)",
      "code": "formatDateToSlash(date) {\n  const d = new Date(date);\n  const month = String(d.getMonth() + 1).padStart(2, '0');\n  const day = String(d.getDate()).padStart(2, '0');\n  const year = d.getFullYear();\n  return `${month}/${day}/${year}`;\n}",
      "typescript": "formatDateToSlash(date: Date): string"
    },
    {
      "name": "parseDate",
      "description": "Parse date string from various formats to Date object",
      "code": "parseDate(dateStr) {\n  const parts = dateStr.split(/[/.]/); \n  const isSlash = dateStr.includes('/');\n  \n  if (isSlash) {\n    // mm/dd/yyyy\n    const [month, day, year] = parts;\n    return new Date(parseInt(year), parseInt(month) - 1, parseInt(day));\n  } else {\n    // dd.mm.yyyy\n    const [day, month, year] = parts;\n    return new Date(parseInt(year), parseInt(month) - 1, parseInt(day));\n  }\n}",
      "typescript": "parseDate(dateStr: string): Date"
    },
    {
      "name": "convertToLocalFormat",
      "description": "Convert mm/dd/yyyy to locale format (e.g., dd.mm.yyyy for Turkish)",
      "code": "convertToLocalFormat(dateStr) {\n  const [month, day, year] = dateStr.split('/');\n  return `${day}.${month}.${year}`;\n}",
      "typescript": "convertToLocalFormat(dateStr: string): string"
    }
  ],
  "codeSnippets": {
    "basicV2": {
      "title": "Basic Date Picker V2",
      "description": "Simple single date selection",
      "code": "<script setup>\nimport { ref } from 'vue';\nimport { InDatePickerV2 } from '@useinsider/design-system-vue';\n\nconst startDate = ref('');\nconst endDate = ref('');\n</script>\n\n<template>\n  <InDatePickerV2\n    id=\"date-v2\"\n    name=\"date-v2\"\n    label-text=\"Select Date\"\n    v-model:start-date=\"startDate\"\n    v-model:end-date=\"endDate\"\n  />\n</template>"
    },
    "rangeV2": {
      "title": "Range Date Picker V2",
      "description": "Date range with custom shortcuts",
      "code": "<script setup>\nimport { ref } from 'vue';\n\nconst startDate = ref('');\nconst endDate = ref('');\n\nconst customRanges = {\n  'Last 7 Days': [\n    new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),\n    new Date()\n  ],\n  'Last 30 Days': [\n    new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),\n    new Date()\n  ],\n  'This Quarter': [\n    new Date(new Date().getFullYear(), Math.floor(new Date().getMonth() / 3) * 3, 1),\n    new Date()\n  ]\n};\n</script>\n\n<template>\n  <InDatePickerV2\n    id=\"range-v2\"\n    name=\"range-v2\"\n    label-text=\"Date Range\"\n    range\n    v-model:start-date=\"startDate\"\n    v-model:end-date=\"endDate\"\n    :custom-ranges=\"customRanges\"\n  />\n</template>"
    },
    "compareV2": {
      "title": "Compare Mode V2",
      "description": "Compare two date ranges",
      "code": "<script setup>\nimport { ref } from 'vue';\n\nconst startDate = ref('');\nconst endDate = ref('');\nconst compareStartDate = ref('');\nconst compareEndDate = ref('');\nconst isCompareEnabled = ref(false);\n\nconst handleCompareToggle = (enabled) => {\n  isCompareEnabled.value = enabled;\n  if (!enabled) {\n    compareStartDate.value = '';\n    compareEndDate.value = '';\n  }\n};\n</script>\n\n<template>\n  <InDatePickerV2\n    id=\"compare-v2\"\n    name=\"compare-v2\"\n    label-text=\"Compare Periods\"\n    range\n    compare\n    v-model:start-date=\"startDate\"\n    v-model:end-date=\"endDate\"\n    v-model:compare-start-date=\"compareStartDate\"\n    v-model:compare-end-date=\"compareEndDate\"\n    @compare-toggle=\"handleCompareToggle\"\n  />\n</template>"
    }
  },
  "styling": {
    "cssVariables": {
      "--datepicker-v2-bg": "Calendar background (default: white)",
      "--datepicker-v2-text": "Text color",
      "--datepicker-v2-border": "Border color",
      "--datepicker-v2-primary": "Primary brand color for selected dates",
      "--datepicker-v2-compare": "Compare range color (default: orange)",
      "--datepicker-v2-range-bg": "Date range background (light blue)",
      "--datepicker-v2-today": "Today's date highlight color"
    },
    "classes": {
      "in-date-picker-v2": "Root container",
      "in-date-picker-v2__input": "Input field container",
      "in-date-picker-v2__calendar": "Calendar dropdown",
      "in-date-picker-v2__day": "Individual day cell",
      "in-date-picker-v2__day--selected": "Selected day",
      "in-date-picker-v2__day--in-range": "Day in primary range",
      "in-date-picker-v2__day--in-compare-range": "Day in compare range",
      "in-date-picker-v2__day--today": "Today's date",
      "in-date-picker-v2__ranges": "Custom ranges sidebar",
      "in-date-picker-v2__compare-toggle": "Compare mode toggle",
      "in-date-picker-v2__footer": "Calendar footer actions"
    },
    "notes": "V2 uses dual v-model for start/end dates. Compare mode adds visual distinction with different colors."
  },
  "implementationPatterns": [
    {
      "name": "Dashboard Analytics Filter",
      "description": "Date range filter with comparison for analytics",
      "code": "<script setup>\nimport { ref, watch } from 'vue';\nimport { InDatePickerV2 } from '@useinsider/design-system-vue';\n\nconst startDate = ref('');\nconst endDate = ref('');\nconst compareStartDate = ref('');\nconst compareEndDate = ref('');\nconst metrics = ref(null);\n\nconst customRanges = {\n  'Today': [new Date(), new Date()],\n  'Yesterday': [\n    new Date(Date.now() - 24 * 60 * 60 * 1000),\n    new Date(Date.now() - 24 * 60 * 60 * 1000)\n  ],\n  'Last 7 Days': [\n    new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),\n    new Date()\n  ],\n  'Last 30 Days': [\n    new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),\n    new Date()\n  ]\n};\n\nconst fetchMetrics = async () => {\n  if (!startDate.value || !endDate.value) return;\n  \n  const params = {\n    start: startDate.value,\n    end: endDate.value\n  };\n  \n  if (compareStartDate.value && compareEndDate.value) {\n    params.compareStart = compareStartDate.value;\n    params.compareEnd = compareEndDate.value;\n  }\n  \n  const response = await fetch('/api/metrics', {\n    method: 'POST',\n    body: JSON.stringify(params)\n  });\n  \n  metrics.value = await response.json();\n};\n\nwatch([startDate, endDate, compareStartDate, compareEndDate], () => {\n  fetchMetrics();\n});\n</script>\n\n<template>\n  <InDatePickerV2\n    id=\"dashboard-filter\"\n    name=\"dashboard-filter\"\n    label-text=\"Date Range\"\n    range\n    compare\n    v-model:start-date=\"startDate\"\n    v-model:end-date=\"endDate\"\n    v-model:compare-start-date=\"compareStartDate\"\n    v-model:compare-end-date=\"compareEndDate\"\n    :custom-ranges=\"customRanges\"\n  />\n</template>",
      "when": "Building analytics dashboards with period comparison",
      "pros": [
        "Dual v-model for clean state",
        "Built-in comparison UI",
        "Flexible custom ranges"
      ],
      "cons": [
        "More complex than V1",
        "Requires v-model:start-date and v-model:end-date"
      ]
    },
    {
      "name": "Campaign Date Selection",
      "description": "Select campaign start and end dates with validation",
      "code": "<script setup>\nimport { ref, computed } from 'vue';\nimport { InDatePickerV2 } from '@useinsider/design-system-vue';\n\nconst startDate = ref('');\nconst endDate = ref('');\n\nconst minDate = Math.floor(new Date().setHours(0, 0, 0, 0) / 1000);\n\nconst state = computed(() => {\n  if (!startDate.value || !endDate.value) return 'error';\n  \n  const start = new Date(startDate.value);\n  const end = new Date(endDate.value);\n  const diffDays = (end - start) / (1000 * 60 * 60 * 24);\n  \n  if (diffDays < 1) return 'error';\n  if (diffDays > 90) return 'warning';\n  return 'success';\n});\n\nconst stateMessage = computed(() => {\n  if (!startDate.value || !endDate.value) {\n    return 'Please select campaign dates';\n  }\n  \n  const start = new Date(startDate.value);\n  const end = new Date(endDate.value);\n  const diffDays = Math.round((end - start) / (1000 * 60 * 60 * 24));\n  \n  if (diffDays < 1) return 'End date must be after start date';\n  if (diffDays > 90) return 'Campaign duration exceeds 90 days';\n  return `Campaign duration: ${diffDays} days`;\n});\n</script>\n\n<template>\n  <InDatePickerV2\n    id=\"campaign-dates\"\n    name=\"campaign-dates\"\n    label-text=\"Campaign Period\"\n    range\n    v-model:start-date=\"startDate\"\n    v-model:end-date=\"endDate\"\n    :min-date=\"minDate\"\n    :state=\"state\"\n    :state-message=\"stateMessage\"\n  />\n</template>",
      "when": "Campaign or event scheduling with date validation",
      "pros": [
        "Date range validation",
        "Visual feedback",
        "Min date restriction"
      ],
      "cons": [
        "Complex validation logic",
        "Multiple computed properties"
      ]
    },
    {
      "name": "Report Generator",
      "description": "Generate reports with flexible date ranges",
      "code": "<script setup>\nimport { ref } from 'vue';\nimport { InDatePickerV2 } from '@useinsider/design-system-vue';\n\nconst startDate = ref('');\nconst endDate = ref('');\nconst reportType = ref('daily');\nconst loading = ref(false);\n\nconst customRanges = {\n  'This Week': [\n    new Date(Date.now() - new Date().getDay() * 24 * 60 * 60 * 1000),\n    new Date()\n  ],\n  'This Month': [\n    new Date(new Date().getFullYear(), new Date().getMonth(), 1),\n    new Date()\n  ],\n  'This Quarter': [\n    new Date(new Date().getFullYear(), Math.floor(new Date().getMonth() / 3) * 3, 1),\n    new Date()\n  ],\n  'This Year': [\n    new Date(new Date().getFullYear(), 0, 1),\n    new Date()\n  ]\n};\n\nconst generateReport = async () => {\n  if (!startDate.value || !endDate.value) {\n    alert('Please select date range');\n    return;\n  }\n  \n  loading.value = true;\n  try {\n    const response = await fetch('/api/reports/generate', {\n      method: 'POST',\n      body: JSON.stringify({\n        startDate: startDate.value,\n        endDate: endDate.value,\n        type: reportType.value\n      })\n    });\n    \n    const blob = await response.blob();\n    const url = window.URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `report-${startDate.value}-${endDate.value}.pdf`;\n    a.click();\n  } catch (error) {\n    console.error('Report generation failed:', error);\n  } finally {\n    loading.value = false;\n  }\n};\n</script>\n\n<template>\n  <div class=\"report-generator\">\n    <InDatePickerV2\n      id=\"report-dates\"\n      name=\"report-dates\"\n      label-text=\"Report Period\"\n      range\n      v-model:start-date=\"startDate\"\n      v-model:end-date=\"endDate\"\n      :custom-ranges=\"customRanges\"\n    />\n    \n    <button \n      @click=\"generateReport\" \n      :disabled=\"loading || !startDate || !endDate\"\n    >\n      {{ loading ? 'Generating...' : 'Generate Report' }}\n    </button>\n  </div>\n</template>",
      "when": "Generating date-based reports or exports",
      "pros": [
        "Flexible date selection",
        "Quick presets",
        "Export functionality"
      ],
      "cons": [
        "Requires backend integration",
        "File download handling"
      ]
    }
  ],
  "useCases": [
    {
      "title": "Analytics Dashboard",
      "description": "Filter analytics with date range and comparison",
      "example": "<InDatePickerV2\n  label-text=\"Analytics Period\"\n  range\n  compare\n  v-model:start-date=\"startDate\"\n  v-model:end-date=\"endDate\"\n  v-model:compare-start-date=\"compareStart\"\n  v-model:compare-end-date=\"compareEnd\"\n/>"
    },
    {
      "title": "Campaign Scheduler",
      "description": "Schedule campaign with date validation",
      "example": "<InDatePickerV2\n  label-text=\"Campaign Period\"\n  range\n  v-model:start-date=\"campaignStart\"\n  v-model:end-date=\"campaignEnd\"\n  :min-date=\"todayTimestamp\"\n  :state=\"validationState\"\n/>"
    },
    {
      "title": "Report Generator",
      "description": "Select date range for report generation",
      "example": "<InDatePickerV2\n  label-text=\"Report Period\"\n  range\n  v-model:start-date=\"reportStart\"\n  v-model:end-date=\"reportEnd\"\n  :custom-ranges=\"reportRanges\"\n/>"
    },
    {
      "title": "Sales Comparison",
      "description": "Compare sales across two periods",
      "example": "<InDatePickerV2\n  label-text=\"Sales Period\"\n  range\n  compare\n  v-model:start-date=\"salesStart\"\n  v-model:end-date=\"salesEnd\"\n  @compare-toggle=\"handleCompareToggle\"\n/>"
    }
  ],
  "bestPractices": [
    {
      "title": "Always Use Dual v-model",
      "description": "V2 requires separate v-model for start and end dates",
      "code": "// Correct V2 usage\n<InDatePickerV2\n  v-model:start-date=\"startDate\"\n  v-model:end-date=\"endDate\"\n/>\n\n// Wrong (V1 style)\n<InDatePickerV2 v-model=\"dateRange\" />",
      "reasoning": "V2 uses dual v-model for better flexibility and state management"
    },
    {
      "title": "Provide Custom Ranges for Analytics",
      "description": "Include common analytics periods as shortcuts",
      "code": "const customRanges = {\n  'Today': [new Date(), new Date()],\n  'Last 7 Days': [new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), new Date()],\n  'Last 30 Days': [new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), new Date()],\n  'This Month': [new Date(new Date().getFullYear(), new Date().getMonth(), 1), new Date()],\n  'Last Month': [\n    new Date(new Date().getFullYear(), new Date().getMonth() - 1, 1),\n    new Date(new Date().getFullYear(), new Date().getMonth(), 0)\n  ]\n};",
      "reasoning": "Common presets improve UX and reduce selection time"
    },
    {
      "title": "Handle Compare Mode Properly",
      "description": "Clear compare dates when compare is disabled",
      "code": "const handleCompareToggle = (enabled) => {\n  if (!enabled) {\n    compareStartDate.value = '';\n    compareEndDate.value = '';\n  }\n};",
      "reasoning": "Prevents stale compare data when toggling compare mode"
    },
    {
      "title": "Set Unique ID and Name",
      "description": "Required for accessibility and form submissions",
      "code": "<InDatePickerV2\n  id=\"analytics-date\"\n  name=\"analytics-date\"\n  label-text=\"Date Range\"\n/>",
      "reasoning": "Improves accessibility and form integration"
    }
  ],
  "commonMistakes": [
    {
      "mistake": "Using single v-model instead of dual v-model",
      "why": "V2 uses v-model:start-date and v-model:end-date",
      "impact": "Component won't work, dates won't bind",
      "fix": "Use v-model:start-date and v-model:end-date",
      "severity": "critical",
      "example": "// Wrong:\n<InDatePickerV2 v-model=\"dateRange\" />\n\n// Correct:\n<InDatePickerV2\n  v-model:start-date=\"startDate\"\n  v-model:end-date=\"endDate\"\n/>"
    },
    {
      "mistake": "Not clearing compare dates when toggling off",
      "why": "Compare dates persist when compare is disabled",
      "impact": "Stale comparison data sent to API",
      "fix": "Clear compare dates on @compare-toggle event",
      "severity": "high",
      "example": "// Add handler:\n@compare-toggle=\"(enabled) => {\n  if (!enabled) {\n    compareStartDate = '';\n    compareEndDate = '';\n  }\n}\""
    },
    {
      "mistake": "Creating custom ranges in template",
      "why": "New Date objects created on every render",
      "impact": "Performance degradation",
      "fix": "Move to data() or setup() function",
      "severity": "medium",
      "example": "// Wrong:\n:custom-ranges=\"{ 'Today': [new Date(), new Date()] }\"\n\n// Correct:\nconst customRanges = { 'Today': [new Date(), new Date()] };"
    }
  ],
  "performanceNotes": [
    {
      "topic": "Compared custom ranges recalculation",
      "description": "Recalculating comparedCustomRanges on every render is inefficient",
      "recommendation": "Use watch with immediate: false instead of computed",
      "impact": "low"
    },
    {
      "topic": "Component re-rendering",
      "description": "Missing reactive key causes component not to re-render on comparison toggle",
      "recommendation": "Add :key=\"`${datePickerKey}-${startDate}-${endDate}`\" if needed",
      "impact": "medium"
    }
  ],
  "accessibilityNotes": [
    {
      "topic": "Label text requirement",
      "description": "Date picker must have descriptive label",
      "wcagLevel": "A",
      "recommendation": "Always provide label-text prop",
      "example": "<InDatePickerV2 label-text=\"Select Date Range\" />"
    },
    {
      "topic": "Unique ID and name",
      "description": "Required for screen reader navigation and form accessibility",
      "wcagLevel": "A",
      "recommendation": "Set unique id and name props",
      "example": "<InDatePickerV2\n  id=\"date-range-picker\"\n  name=\"date-range-picker\"\n  label-text=\"Date Range\"\n/>"
    },
    {
      "topic": "Keyboard navigation",
      "description": "Calendar must be fully keyboard accessible",
      "wcagLevel": "A",
      "recommendation": "Arrow keys navigate, Enter selects, Escape closes, Tab moves between inputs",
      "example": "// Automatically supported by component"
    }
  ]
}
