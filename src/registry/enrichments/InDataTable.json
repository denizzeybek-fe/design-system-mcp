{
  "component": "InDataTable",
  "_metadata": {
    "lastUpdated": "2025-11-25T16:45:00Z",
    "propsHash": "b81668415884",
    "eventsHash": "41c59fa49883",
    "propCount": 43,
    "eventCount": 5
  },
  "propEnrichments": {
    "tableFields": {
      "valueFormat": {
        "structure": "Array<Object>",
        "notes": "REQUIRED: Array of column definition objects. Each must have 'field' and 'label' properties",
        "examples": [
          "[{ field: 'name', label: 'Name', sortable: true }]",
          "[{ field: 'id', label: 'ID', width: 80 }, { field: 'email', label: 'Email', sortable: true, renderer: 'email' }]"
        ],
        "typescript": "Array<{ field: string; label: string; sortable?: boolean; width?: number; renderer?: string; formatter?: Function; }>"
      },
      "relatedProps": [
        "data",
        "formatMapping"
      ],
      "commonMistakes": [
        {
          "mistake": "Not providing 'field' property in column definition",
          "impact": "Column shows undefined or doesn't render",
          "fix": "Each column must have: { field: 'propertyName', label: 'Display Name' }",
          "severity": "critical"
        },
        {
          "mistake": "Using 'title' instead of 'label' for column header",
          "impact": "Column header doesn't display",
          "fix": "V1 uses 'label' property, not 'title'",
          "severity": "high"
        },
        {
          "mistake": "Field name doesn't match data object keys",
          "impact": "Column shows empty values",
          "fix": "Ensure field: 'email' matches data object key: { email: 'test@example.com' }",
          "severity": "high"
        }
      ]
    },
    "httpFetch": {
      "valueFormat": {
        "structure": "Function",
        "notes": "CRITICAL: Custom HTTP client function for API requests. Use when you need custom auth, interceptors, or error handling. Replaces default fetch behavior",
        "examples": [
          "async (url, options) => await axios.get(url, options)",
          "(url, options) => customFetchWithRetry(url, options)"
        ],
        "typescript": "(url: string, options?: RequestInit) => Promise<Response>"
      },
      "relatedProps": [
        "fetchUrl",
        "apiMode",
        "httpOptions"
      ],
      "commonMistakes": [
        {
          "mistake": "Not returning a Promise from httpFetch",
          "impact": "Table loading fails silently or throws errors",
          "fix": "httpFetch must return Promise<Response>: async (url, options) => await fetch(url, options)",
          "severity": "critical"
        },
        {
          "mistake": "Using httpFetch without setting apiMode=true",
          "impact": "Custom fetch function never gets called",
          "fix": "Always set api-mode when providing :http-fetch",
          "severity": "high"
        },
        {
          "mistake": "Not handling errors in custom httpFetch",
          "impact": "Unhandled promise rejections, poor error UX",
          "fix": "Wrap in try-catch and return proper Response: try { return await axios(...) } catch (e) { throw new Error(...) }",
          "severity": "high"
        },
        {
          "mistake": "Forgetting to merge httpOptions into custom fetch",
          "impact": "Headers and credentials from httpOptions prop are ignored",
          "fix": "Merge options: httpFetch: (url, opts) => fetch(url, { ...opts, ...httpOptions.value })",
          "severity": "medium"
        }
      ]
    },
    "data": {
      "valueFormat": {
        "structure": "Array<Object>",
        "notes": "Table data array for client-side mode (when apiMode=false). Each object represents a row",
        "typescript": "Array<Record<string, any>>"
      },
      "relatedProps": [
        "apiMode",
        "fetchUrl"
      ],
      "commonMistakes": [
        {
          "mistake": "Providing both :data and fetch-url",
          "impact": "Confusing behavior - which data source is used depends on apiMode",
          "fix": "Use :data for client-side OR fetch-url for server-side, not both",
          "severity": "medium"
        }
      ]
    },
    "fetchUrl": {
      "valueFormat": {
        "structure": "string (URL)",
        "notes": "API endpoint for server-side data fetching. Requires apiMode=true",
        "examples": [
          "/api/users",
          "https://api.example.com/v1/customers"
        ],
        "typescript": "string"
      },
      "relatedProps": [
        "apiMode",
        "httpFetch",
        "httpOptions",
        "tableSearchParams"
      ],
      "commonMistakes": [
        {
          "mistake": "Using fetchUrl without setting apiMode=true",
          "impact": "Table doesn't fetch data, shows empty state",
          "fix": "Always set api-mode when using fetch-url",
          "severity": "critical"
        },
        {
          "mistake": "Not handling CORS for external APIs",
          "impact": "API requests fail with CORS errors",
          "fix": "Ensure API has proper CORS headers or use proxy",
          "severity": "high"
        }
      ]
    },
    "apiMode": {
      "valueFormat": {
        "structure": "boolean",
        "notes": "Enable server-side data fetching. When true, uses fetchUrl instead of local data",
        "typescript": "boolean"
      },
      "relatedProps": [
        "fetchUrl",
        "data"
      ]
    },
    "tableSearchParams": {
      "valueFormat": {
        "structure": "Object",
        "notes": "Additional query parameters sent with API requests. Merged with pagination/sort/filter params",
        "examples": [
          "{ status: 'active', type: 'user' }",
          "{ tenant_id: tenantId, role: 'admin' }"
        ],
        "typescript": "Record<string, string | number | boolean>"
      },
      "relatedProps": [
        "fetchUrl",
        "apiMode"
      ]
    },
    "actions": {
      "valueFormat": {
        "structure": "Array<Object>",
        "notes": "Row action buttons configuration. Creates action column with buttons for each row",
        "examples": [
          "[{ name: 'edit', icon: 'edit', label: 'Edit' }]",
          "[{ name: 'delete', icon: 'trash', label: 'Delete', handler: deleteRow }]"
        ],
        "typescript": "Array<{ name: string; icon?: string; label?: string; handler?: (row: any) => void; }>"
      }
    },
    "perPage": {
      "valueFormat": {
        "structure": "number",
        "notes": "Number of rows per page. Default: 10",
        "typescript": "number"
      },
      "relatedProps": [
        "paginationStatus"
      ]
    },
    "sortOrder": {
      "valueFormat": {
        "structure": "Object",
        "notes": "Default sort configuration applied on initial load",
        "examples": [
          "{ field: 'createdAt', direction: 'desc' }",
          "{ field: 'name', direction: 'asc' }"
        ],
        "typescript": "{ field: string; direction: 'asc' | 'desc' }"
      }
    },
    "paginationPath": {
      "valueFormat": {
        "structure": "string",
        "notes": "JSON path to pagination data in API response. Uses dot notation for nested objects",
        "examples": [
          "meta.pagination",
          "data.pagination",
          "pagination"
        ],
        "typescript": "string"
      },
      "relatedProps": [
        "apiMode",
        "fetchUrl"
      ],
      "commonMistakes": [
        {
          "mistake": "Wrong pagination path for API response structure",
          "impact": "Pagination doesn't work, shows wrong page count",
          "fix": "Inspect API response and set correct path: pagination-path=\"meta.pagination\"",
          "severity": "high"
        }
      ]
    },
    "httpOptions": {
      "valueFormat": {
        "structure": "Object",
        "notes": "HTTP request configuration for API calls (headers, credentials, etc.)",
        "examples": [
          "{ headers: { 'Authorization': 'Bearer token' } }",
          "{ headers: { 'X-API-Key': apiKey }, credentials: 'include' }"
        ],
        "typescript": "{ headers?: Record<string, string>; credentials?: 'include' | 'same-origin' | 'omit'; }"
      },
      "relatedProps": [
        "fetchUrl",
        "httpFetch"
      ],
      "commonMistakes": [
        {
          "mistake": "Not providing Authorization header for authenticated APIs",
          "impact": "API requests fail with 401 Unauthorized",
          "fix": "Pass auth header: :http-options=\"{ headers: { 'Authorization': `Bearer ${token}` } }\"",
          "severity": "critical"
        }
      ]
    },
    "trackBy": {
      "valueFormat": {
        "structure": "string",
        "notes": "Unique identifier field for row tracking. Critical for selection and detail rows. Default: 'id'",
        "examples": [
          "id",
          "userId",
          "uuid"
        ],
        "typescript": "string"
      },
      "commonMistakes": [
        {
          "mistake": "Using non-unique field for trackBy",
          "impact": "Row selection breaks, detail rows don't work properly",
          "fix": "Use truly unique field: track-by=\"id\" or track-by=\"uuid\"",
          "severity": "high"
        }
      ]
    },
    "formatMapping": {
      "valueFormat": {
        "structure": "Object",
        "notes": "Custom formatter functions for specific fields. Maps field names to formatter functions",
        "examples": [
          "{ createdAt: (val) => formatDate(val), price: (val) => `$${val.toFixed(2)}` }",
          "{ status: (val) => val.toUpperCase() }"
        ],
        "typescript": "Record<string, (value: any, row?: any) => string>"
      }
    },
    "rowClass": {
      "valueFormat": {
        "structure": "Function | string",
        "notes": "Dynamic class applied to rows based on row data. Can be string or function",
        "examples": [
          "(row) => row.status === 'error' ? 'bg-red-50' : ''",
          "(row) => row.isPinned ? 'font-bold' : ''"
        ],
        "typescript": "string | ((row: any) => string)"
      },
      "commonMistakes": [
        {
          "mistake": "Complex logic in rowClass function",
          "impact": "Performance issues - function called for every row on every render",
          "fix": "Keep function simple or memoize results",
          "severity": "medium"
        }
      ]
    },
    "loadingType": {
      "valueFormat": {
        "structure": "string (enum)",
        "validValues": [
          "spinner",
          "skeleton",
          "overlay"
        ],
        "notes": "Type of loading indicator shown during data fetch",
        "typescript": "'spinner' | 'skeleton' | 'overlay'"
      },
      "relatedProps": [
        "loadingStatus"
      ],
      "possibleValues": [
        {
          "value": "skeleton",
          "description": "TODO: Add description for 'skeleton'"
        },
        {
          "value": "no-data",
          "description": "TODO: Add description for 'no-data'"
        }
      ]
    }
  },
  "eventEnrichments": {
    "onLoad": {
      "payloadFormat": {
        "structure": "{ data: Array, total: number }",
        "notes": "Emitted when table data is loaded (both initial and refreshes)"
      }
    },
    "setPaginationObject": {
      "payloadFormat": {
        "structure": "{ page: number, perPage: number, total: number }",
        "notes": "Emitted when pagination state changes (page change, perPage change)"
      }
    },
    "paginationCount": {
      "payloadFormat": {
        "structure": "number",
        "notes": "Emitted with total record count from API response"
      }
    },
    "perPage": {
      "payloadFormat": {
        "structure": "number",
        "notes": "Emitted when user changes per-page selection in pagination dropdown"
      }
    },
    "selectStatus": {
      "payloadFormat": {
        "structure": "{ selectedRows: Array, allSelected: boolean }",
        "notes": "Emitted when row selection changes. selectedRows contains full row objects"
      }
    }
  },
  "codeSnippets": {
    "template": {
      "clientSide": "<InDataTable\n  name=\"users-table\"\n  :data=\"users\"\n  :table-fields=\"[\n    { field: 'name', label: 'Name', sortable: true },\n    { field: 'email', label: 'Email' },\n    { field: 'status', label: 'Status' }\n  ]\"\n  :per-page=\"10\"\n  pagination-status\n  track-by=\"id\"\n/>",
      "serverSide": "<InDataTable\n  name=\"api-table\"\n  api-mode\n  fetch-url=\"/api/users\"\n  :table-search-params=\"{ tenant: tenantId }\"\n  :table-fields=\"columns\"\n  :http-options=\"{ headers: { 'Authorization': authToken } }\"\n  pagination-path=\"meta.pagination\"\n  :per-page=\"25\"\n  with-search-filter\n  @on-load=\"handleLoad\"\n/>",
      "customFetch": "<InDataTable\n  name=\"custom-fetch-table\"\n  api-mode\n  fetch-url=\"/api/data\"\n  :http-fetch=\"customHttpClient\"\n  :table-fields=\"columns\"\n  :per-page=\"20\"\n/>",
      "withActions": "<InDataTable\n  name=\"actions-table\"\n  :data=\"data\"\n  :table-fields=\"columns\"\n  :actions=\"[\n    { name: 'edit', icon: 'line-edit', label: 'Edit', handler: handleEdit },\n    { name: 'delete', icon: 'line-trash', label: 'Delete', handler: handleDelete }\n  ]\"\n  track-by=\"id\"\n/>",
      "fixedColumns": "<InDataTable\n  name=\"wide-table\"\n  :data=\"data\"\n  :table-fields=\"manyColumns\"\n  horizontal-scroll\n  fix-first-column\n  fix-last-column\n/>",
      "formatted": "<InDataTable\n  name=\"formatted-table\"\n  :data=\"data\"\n  :table-fields=\"columns\"\n  :format-mapping=\"{\n    createdAt: formatDate,\n    price: formatCurrency,\n    status: formatStatus\n  }\"\n/>",
      "withFilters": "<InDataTable\n  name=\"filtered-table\"\n  api-mode\n  fetch-url=\"/api/items\"\n  :table-fields=\"columns\"\n  with-search-filter\n  with-status-filter\n  :status-list=\"[\n    { label: 'Active', value: 'active' },\n    { label: 'Inactive', value: 'inactive' }\n  ]\"\n/>",
      "rowStyling": "<InDataTable\n  name=\"styled-table\"\n  :data=\"data\"\n  :table-fields=\"columns\"\n  :row-class=\"row => row.status === 'error' ? 'bg-red-50' : ''\"\n/>",
      "loading": "<InDataTable\n  name=\"loading-table\"\n  api-mode\n  fetch-url=\"/api/data\"\n  :table-fields=\"columns\"\n  :loading-status=\"isLoading\"\n  loading-type=\"skeleton\"\n/>"
    },
    "script": "import { ref, computed } from 'vue';\nimport { InDataTable } from '@useinsider/design-system-vue';\nimport '@useinsider/design-system-vue/dist/design-system-vue.css';\nimport axios from 'axios';\n\nconst users = ref([]);\nconst isLoading = ref(false);\nconst authToken = ref('Bearer your-token-here');\n\nconst columns = ref([\n  { field: 'id', label: 'ID', width: 80 },\n  { field: 'name', label: 'Name', sortable: true },\n  { field: 'email', label: 'Email', sortable: true },\n  { field: 'createdAt', label: 'Created', sortable: true },\n  { field: 'status', label: 'Status' }\n]);\n\n// Custom HTTP client with axios\nconst customHttpClient = async (url, options) => {\n  try {\n    const response = await axios.get(url, {\n      params: options?.params,\n      headers: options?.headers\n    });\n    // Convert axios response to fetch-like Response\n    return new Response(JSON.stringify(response.data), {\n      status: response.status,\n      headers: response.headers\n    });\n  } catch (error) {\n    throw new Error(`API Error: ${error.message}`);\n  }\n};\n\n// Format functions\nconst formatDate = (value) => {\n  if (!value) return '-';\n  return new Date(value).toLocaleDateString();\n};\n\nconst formatCurrency = (value) => {\n  if (!value) return '$0.00';\n  return `$${parseFloat(value).toFixed(2)}`;\n};\n\nconst formatStatus = (value) => {\n  const statusMap = {\n    active: 'Active',\n    inactive: 'Inactive',\n    pending: 'Pending'\n  };\n  return statusMap[value] || value;\n};\n\n// Event handlers\nconst handleLoad = (payload) => {\n  console.log('Data loaded:', payload.data.length, 'rows');\n  console.log('Total:', payload.total);\n};\n\nconst handleEdit = (row) => {\n  console.log('Edit row:', row.id);\n  // router.push(`/edit/${row.id}`);\n};\n\nconst handleDelete = async (row) => {\n  if (confirm(`Delete ${row.name}?`)) {\n    // await api.delete(`/users/${row.id}`);\n    console.log('Deleted:', row.id);\n  }\n};\n\nconst handleSelection = (payload) => {\n  console.log('Selected rows:', payload.selectedRows);\n  console.log('All selected:', payload.allSelected);\n};",
    "style": "/* InDataTable component styling */\n\n/* Table wrapper */\n.in-data-table {\n  width: 100%;\n  overflow-x: auto;\n}\n\n/* Table header */\n.in-data-table__header {\n  background-color: #f5f5f5;\n  border-bottom: 2px solid #e0e0e0;\n}\n\n/* Table rows */\n.in-data-table__row {\n  border-bottom: 1px solid #e0e0e0;\n  transition: background-color 0.2s;\n}\n\n.in-data-table__row:hover {\n  background-color: #f9f9f9;\n}\n\n/* Custom row classes */\n.bg-red-50 {\n  background-color: #ffebee;\n}\n\n.error-row {\n  background-color: #ffebee;\n  color: #c62828;\n}\n\n.success-row {\n  background-color: #e8f5e9;\n}\n\n/* Fixed columns */\n.in-data-table--fixed-first .in-data-table__cell:first-child {\n  position: sticky;\n  left: 0;\n  background-color: #fff;\n  z-index: 10;\n}\n\n.in-data-table--fixed-last .in-data-table__cell:last-child {\n  position: sticky;\n  right: 0;\n  background-color: #fff;\n  z-index: 10;\n}\n\n/* Horizontal scroll */\n.in-data-table--scroll {\n  overflow-x: auto;\n  max-width: 100%;\n}\n\n/* Pagination */\n.in-data-table__pagination {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 16px;\n  border-top: 1px solid #e0e0e0;\n}\n\n/* Loading skeleton */\n.in-data-table__skeleton {\n  animation: pulse 1.5s ease-in-out infinite;\n}\n\n@keyframes pulse {\n  0%, 100% { opacity: 1; }\n  50% { opacity: 0.5; }\n}"
  },
  "styling": {
    "positioning": "static",
    "layout": "block",
    "fullWidth": true,
    "zIndex": null,
    "customization": {
      "cssClasses": [
        "in-data-table",
        "in-data-table__header",
        "in-data-table__row",
        "in-data-table__cell",
        "in-data-table__pagination",
        "in-data-table--fixed-first",
        "in-data-table--fixed-last",
        "in-data-table--scroll"
      ],
      "cssVariables": [],
      "themeable": false,
      "notes": "Use rowClass prop for dynamic row styling. Fixed columns use position: sticky"
    },
    "responsive": {
      "mobile": true,
      "tablet": true,
      "desktop": true,
      "notes": "Use horizontal-scroll on mobile for wide tables. Consider hiding less important columns on mobile"
    }
  },
  "examples": [
    {
      "title": "Basic Client-Side Table",
      "description": "Simple table with local data and pagination",
      "category": "basic",
      "code": "<template>\n  <InDataTable\n    name=\"users-table\"\n    :data=\"users\"\n    :table-fields=\"columns\"\n    :per-page=\"10\"\n    pagination-status\n    track-by=\"id\"\n  />\n</template>\n\n<script setup>\nimport { ref } from 'vue';\n\nconst users = ref([\n  { id: 1, name: 'John Doe', email: 'john@example.com', status: 'active' },\n  { id: 2, name: 'Jane Smith', email: 'jane@example.com', status: 'inactive' }\n]);\n\nconst columns = ref([\n  { field: 'name', label: 'Name', sortable: true },\n  { field: 'email', label: 'Email' },\n  { field: 'status', label: 'Status' }\n]);\n</script>",
      "language": "vue"
    },
    {
      "title": "Server-Side Table with API",
      "description": "Table fetching data from API endpoint with authentication",
      "category": "advanced",
      "code": "<template>\n  <InDataTable\n    name=\"api-table\"\n    api-mode\n    fetch-url=\"/api/users\"\n    :table-search-params=\"searchParams\"\n    :table-fields=\"columns\"\n    :http-options=\"httpOptions\"\n    pagination-path=\"meta.pagination\"\n    :per-page=\"25\"\n    with-search-filter\n    with-status-filter\n    :status-list=\"statusOptions\"\n    @on-load=\"handleLoad\"\n  />\n</template>\n\n<script setup>\nimport { ref, computed } from 'vue';\n\nconst authToken = ref('Bearer your-token-here');\nconst tenantId = ref('tenant-123');\n\nconst httpOptions = computed(() => ({\n  headers: {\n    'Authorization': authToken.value,\n    'X-Tenant-ID': tenantId.value\n  }\n}));\n\nconst searchParams = computed(() => ({\n  tenant: tenantId.value\n}));\n\nconst columns = ref([\n  { field: 'id', label: 'ID', width: 80 },\n  { field: 'name', label: 'Name', sortable: true },\n  { field: 'email', label: 'Email', sortable: true },\n  { field: 'status', label: 'Status' }\n]);\n\nconst statusOptions = ref([\n  { label: 'Active', value: 'active' },\n  { label: 'Inactive', value: 'inactive' },\n  { label: 'Pending', value: 'pending' }\n]);\n\nconst handleLoad = (payload) => {\n  console.log(`Loaded ${payload.data.length} rows`);\n};\n</script>",
      "language": "vue"
    },
    {
      "title": "Custom HTTP Client with Axios",
      "description": "Using custom HTTP client for advanced request handling",
      "category": "advanced",
      "code": "<template>\n  <InDataTable\n    name=\"axios-table\"\n    api-mode\n    fetch-url=\"/api/data\"\n    :http-fetch=\"axiosClient\"\n    :table-fields=\"columns\"\n    :per-page=\"20\"\n  />\n</template>\n\n<script setup>\nimport axios from 'axios';\n\nconst axiosClient = async (url, options) => {\n  try {\n    const response = await axios.get(url, {\n      params: options?.params,\n      headers: options?.headers,\n      timeout: 10000 // 10 second timeout\n    });\n    \n    // Convert axios response to fetch Response\n    return new Response(JSON.stringify(response.data), {\n      status: response.status,\n      statusText: response.statusText,\n      headers: new Headers(response.headers)\n    });\n  } catch (error) {\n    console.error('API Error:', error);\n    throw error;\n  }\n};\n\nconst columns = ref([\n  { field: 'id', label: 'ID' },\n  { field: 'name', label: 'Name', sortable: true }\n]);\n</script>",
      "language": "vue"
    },
    {
      "title": "Table with Row Actions",
      "description": "Action buttons for each row with handlers",
      "category": "actions",
      "code": "<template>\n  <InDataTable\n    name=\"actions-table\"\n    :data=\"items\"\n    :table-fields=\"columns\"\n    :actions=\"rowActions\"\n    track-by=\"id\"\n  />\n</template>\n\n<script setup>\nimport { ref } from 'vue';\n\nconst items = ref([\n  { id: 1, name: 'Item 1', status: 'active' },\n  { id: 2, name: 'Item 2', status: 'inactive' }\n]);\n\nconst columns = ref([\n  { field: 'id', label: 'ID', width: 80 },\n  { field: 'name', label: 'Name' },\n  { field: 'status', label: 'Status' }\n]);\n\nconst rowActions = ref([\n  {\n    name: 'edit',\n    icon: 'line-edit',\n    label: 'Edit',\n    handler: (row) => {\n      console.log('Edit:', row.id);\n      // Navigate to edit page\n    }\n  },\n  {\n    name: 'delete',\n    icon: 'line-trash',\n    label: 'Delete',\n    handler: async (row) => {\n      if (confirm(`Delete ${row.name}?`)) {\n        // await deleteItem(row.id);\n        console.log('Deleted:', row.id);\n      }\n    }\n  }\n]);\n</script>",
      "language": "vue"
    },
    {
      "title": "Wide Table with Fixed Columns",
      "description": "Horizontal scrolling with fixed first and last columns",
      "category": "layout",
      "code": "<InDataTable\n  name=\"wide-table\"\n  :data=\"data\"\n  :table-fields=\"manyColumns\"\n  horizontal-scroll\n  fix-first-column\n  fix-last-column\n  :per-page=\"15\"\n/>",
      "language": "vue"
    },
    {
      "title": "Formatted Values",
      "description": "Custom formatting for dates, currency, and status",
      "category": "formatting",
      "code": "<template>\n  <InDataTable\n    name=\"formatted-table\"\n    :data=\"transactions\"\n    :table-fields=\"columns\"\n    :format-mapping=\"formatters\"\n  />\n</template>\n\n<script setup>\nimport { ref } from 'vue';\n\nconst transactions = ref([\n  { id: 1, amount: 1234.56, createdAt: '2025-01-15T10:30:00Z', status: 'completed' }\n]);\n\nconst columns = ref([\n  { field: 'id', label: 'ID' },\n  { field: 'amount', label: 'Amount' },\n  { field: 'createdAt', label: 'Date' },\n  { field: 'status', label: 'Status' }\n]);\n\nconst formatters = ref({\n  amount: (value) => `$${parseFloat(value).toFixed(2)}`,\n  createdAt: (value) => new Date(value).toLocaleDateString('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric'\n  }),\n  status: (value) => value.charAt(0).toUpperCase() + value.slice(1)\n});\n</script>",
      "language": "vue"
    },
    {
      "title": "Conditional Row Styling",
      "description": "Dynamic row classes based on row data",
      "category": "styling",
      "code": "<template>\n  <InDataTable\n    name=\"styled-table\"\n    :data=\"items\"\n    :table-fields=\"columns\"\n    :row-class=\"getRowClass\"\n  />\n</template>\n\n<script setup>\nimport { ref } from 'vue';\n\nconst items = ref([\n  { id: 1, name: 'Item 1', status: 'error', priority: 'high' },\n  { id: 2, name: 'Item 2', status: 'success', priority: 'low' }\n]);\n\nconst columns = ref([\n  { field: 'name', label: 'Name' },\n  { field: 'status', label: 'Status' },\n  { field: 'priority', label: 'Priority' }\n]);\n\nconst getRowClass = (row) => {\n  if (row.status === 'error') return 'bg-red-50 text-red-900';\n  if (row.status === 'success') return 'bg-green-50';\n  if (row.priority === 'high') return 'font-bold';\n  return '';\n};\n</script>\n\n<style scoped>\n.bg-red-50 { background-color: #ffebee; }\n.text-red-900 { color: #b71c1c; }\n.bg-green-50 { background-color: #e8f5e9; }\n</style>",
      "language": "vue"
    },
    {
      "title": "Loading States",
      "description": "Skeleton loading for better UX",
      "category": "states",
      "code": "<template>\n  <InDataTable\n    name=\"loading-table\"\n    api-mode\n    fetch-url=\"/api/data\"\n    :table-fields=\"columns\"\n    :loading-status=\"isLoading\"\n    loading-type=\"skeleton\"\n    @on-load=\"handleLoad\"\n  />\n</template>\n\n<script setup>\nimport { ref } from 'vue';\n\nconst isLoading = ref(false);\n\nconst columns = ref([\n  { field: 'id', label: 'ID' },\n  { field: 'name', label: 'Name' }\n]);\n\nconst handleLoad = () => {\n  isLoading.value = false;\n};\n</script>",
      "language": "vue"
    },
    {
      "title": "Table with Search and Status Filters",
      "description": "Built-in search and dropdown filters",
      "category": "filters",
      "code": "<InDataTable\n  name=\"filtered-table\"\n  api-mode\n  fetch-url=\"/api/items\"\n  :table-fields=\"columns\"\n  with-search-filter\n  placeholder=\"Search items...\"\n  with-status-filter\n  :status-list=\"[\n    { label: 'All', value: '' },\n    { label: 'Active', value: 'active' },\n    { label: 'Inactive', value: 'inactive' }\n  ]\"\n/>",
      "language": "vue"
    }
  ],
  "implementationPatterns": [
    {
      "pattern": "API integration with auth",
      "when": "Fetching data from authenticated API endpoints",
      "code": "const authToken = ref('');\nconst httpOptions = computed(() => ({\n  headers: {\n    'Authorization': `Bearer ${authToken.value}`,\n    'Content-Type': 'application/json'\n  },\n  credentials: 'include'\n}));\n\n<InDataTable\n  api-mode\n  fetch-url=\"/api/protected/users\"\n  :http-options=\"httpOptions\"\n  :table-fields=\"columns\"\n/>",
      "notes": "Use computed for httpOptions to react to auth token changes"
    },
    {
      "pattern": "Custom fetch with retry logic",
      "when": "Need resilient API calls with automatic retries",
      "code": "const fetchWithRetry = async (url, options, retries = 3) => {\n  for (let i = 0; i < retries; i++) {\n    try {\n      const response = await fetch(url, options);\n      if (response.ok) return response;\n      if (i === retries - 1) throw new Error('Max retries reached');\n    } catch (error) {\n      if (i === retries - 1) throw error;\n      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n    }\n  }\n};\n\n<InDataTable\n  api-mode\n  fetch-url=\"/api/data\"\n  :http-fetch=\"fetchWithRetry\"\n  :table-fields=\"columns\"\n/>",
      "notes": "Exponential backoff: 1s, 2s, 3s delays between retries"
    },
    {
      "pattern": "Real-time data with polling",
      "when": "Table needs to auto-refresh with latest data",
      "code": "const tableRef = ref(null);\nconst pollInterval = ref(null);\n\nonMounted(() => {\n  // Refresh table every 30 seconds\n  pollInterval.value = setInterval(() => {\n    if (tableRef.value) {\n      tableRef.value.refresh(); // Call refresh method\n    }\n  }, 30000);\n});\n\nonUnmounted(() => {\n  if (pollInterval.value) {\n    clearInterval(pollInterval.value);\n  }\n});\n\n<InDataTable\n  ref=\"tableRef\"\n  api-mode\n  fetch-url=\"/api/live-data\"\n  :table-fields=\"columns\"\n/>",
      "notes": "Clear interval on component unmount to prevent memory leaks"
    },
    {
      "pattern": "Export selected rows",
      "when": "Users need to export selected table data",
      "code": "const selectedRows = ref([]);\n\nconst exportToCSV = () => {\n  if (selectedRows.value.length === 0) {\n    alert('No rows selected');\n    return;\n  }\n  \n  const headers = columns.value.map(col => col.label);\n  const rows = selectedRows.value.map(row => \n    columns.value.map(col => row[col.field])\n  );\n  \n  const csv = [\n    headers.join(','),\n    ...rows.map(row => row.join(','))\n  ].join('\\n');\n  \n  const blob = new Blob([csv], { type: 'text/csv' });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = 'export.csv';\n  a.click();\n};\n\n<InDataTable\n  :data=\"data\"\n  :table-fields=\"columns\"\n  @select-status=\"handleSelection\"\n/>\n<InButtonV2 @click=\"exportToCSV\" label-text=\"Export Selected\" />",
      "notes": "Store selected rows from selectStatus event"
    }
  ],
  "useCases": [
    {
      "title": "User Management Dashboard",
      "description": "Display and manage users with search, filters, and actions",
      "example": "Admin panel with user list, role filtering, edit/delete actions"
    },
    {
      "title": "Transaction History",
      "description": "Show financial transactions with formatted currency and dates",
      "example": "Payment history, invoice list with amount formatting"
    },
    {
      "title": "Content Management",
      "description": "List blog posts, products, or content items with status filters",
      "example": "CMS article list with draft/published filters"
    },
    {
      "title": "Analytics Reports",
      "description": "Display metrics and KPIs in tabular format with custom formatting",
      "example": "Sales reports, performance dashboards with percentage formatters"
    },
    {
      "title": "Inventory Management",
      "description": "Product listings with stock levels and actions",
      "example": "Warehouse inventory with low-stock highlighting via rowClass"
    }
  ],
  "bestPractices": [
    {
      "practice": "Always set trackBy for tables with selection or detail rows",
      "why": "Ensures proper row identification and prevents selection bugs",
      "example": "track-by=\"id\" or track-by=\"uuid\"",
      "antiPattern": "Omitting trackBy with non-unique default 'id' field"
    },
    {
      "practice": "Use apiMode for datasets > 100 rows",
      "why": "Client-side rendering of large datasets causes performance issues",
      "example": "api-mode fetch-url=\"/api/users\" for large user lists",
      "antiPattern": "Loading 10,000 rows into :data prop"
    },
    {
      "practice": "Provide httpOptions for all authenticated API calls",
      "why": "Without auth headers, API requests will fail",
      "example": ":http-options=\"{ headers: { 'Authorization': `Bearer ${token}` } }\"",
      "antiPattern": "Expecting table to inherit global axios interceptors"
    },
    {
      "practice": "Use formatMapping for consistent value formatting",
      "why": "Centralizes formatting logic, easier to maintain",
      "example": ":format-mapping=\"{ date: formatDate, price: formatCurrency }\"",
      "antiPattern": "Custom renderer components for simple formatting"
    },
    {
      "practice": "Set proper paginationPath for your API response structure",
      "why": "Incorrect path causes pagination to break",
      "example": "pagination-path=\"meta.pagination\" to match { meta: { pagination: {...} } }",
      "antiPattern": "Guessing pagination path without inspecting API response"
    },
    {
      "practice": "Keep rowClass functions simple",
      "why": "Complex functions hurt performance (called for every row on every render)",
      "example": "row => row.status === 'error' ? 'error-row' : ''",
      "antiPattern": "row => expensiveCalculation(row) + nestedLogic(row.data)"
    },
    {
      "practice": "Use loading states for better UX",
      "why": "Users need feedback during data fetches",
      "example": ":loading-status=\"isLoading\" loading-type=\"skeleton\"",
      "antiPattern": "No loading indicator, users see empty table during fetch"
    }
  ],
  "commonMistakes": [
    {
      "category": "prop-usage",
      "severity": "critical",
      "title": "Using fetchUrl without apiMode=true",
      "description": "Table needs apiMode enabled to fetch from URL",
      "wrong": "<InDataTable fetch-url=\"/api/users\" :table-fields=\"columns\" />",
      "correct": "<InDataTable api-mode fetch-url=\"/api/users\" :table-fields=\"columns\" />",
      "impact": "Table shows empty state, no data fetched"
    },
    {
      "category": "prop-usage",
      "severity": "critical",
      "title": "Missing 'field' property in tableFields",
      "description": "Each column definition must have 'field' matching data key",
      "wrong": ":table-fields=\"[{ label: 'Name' }]\"",
      "correct": ":table-fields=\"[{ field: 'name', label: 'Name' }]\"",
      "impact": "Columns show undefined values or don't render"
    },
    {
      "category": "prop-usage",
      "severity": "critical",
      "title": "httpFetch not returning Promise<Response>",
      "description": "Custom HTTP client must return proper Response object",
      "wrong": ":http-fetch=\"(url) => axios.get(url)\"",
      "correct": ":http-fetch=\"async (url, opts) => { const res = await axios.get(url); return new Response(JSON.stringify(res.data), { status: res.status }); }\"",
      "impact": "Table loading fails with type errors"
    },
    {
      "category": "authentication",
      "severity": "critical",
      "title": "Missing Authorization header for protected APIs",
      "description": "Authenticated endpoints require auth headers in httpOptions",
      "wrong": "<InDataTable api-mode fetch-url=\"/api/protected\" />",
      "correct": "<InDataTable api-mode fetch-url=\"/api/protected\" :http-options=\"{ headers: { 'Authorization': authToken } }\" />",
      "impact": "API requests fail with 401 Unauthorized"
    },
    {
      "category": "prop-usage",
      "severity": "high",
      "title": "Wrong paginationPath for API response",
      "description": "Path must match your API's pagination data location",
      "wrong": "pagination-path=\"pagination\" for API response { meta: { pagination: {...} } }",
      "correct": "pagination-path=\"meta.pagination\"",
      "impact": "Pagination broken, wrong page counts"
    },
    {
      "category": "prop-usage",
      "severity": "high",
      "title": "Using 'title' instead of 'label' in tableFields",
      "description": "V1 uses 'label' property for column headers",
      "wrong": ":table-fields=\"[{ field: 'name', title: 'Name' }]\"",
      "correct": ":table-fields=\"[{ field: 'name', label: 'Name' }]\"",
      "impact": "Column headers don't display"
    },
    {
      "category": "performance",
      "severity": "medium",
      "title": "Loading large datasets client-side",
      "description": "Client-side mode not suitable for > 1000 rows",
      "wrong": ":data=\"tenThousandRows\"",
      "correct": "api-mode fetch-url=\"/api/data\" with server-side pagination",
      "impact": "Page freezes, poor performance"
    },
    {
      "category": "prop-usage",
      "severity": "medium",
      "title": "Complex logic in rowClass function",
      "description": "rowClass called for every row on every render",
      "wrong": ":row-class=\"row => expensiveCalculation(row)\"",
      "correct": ":row-class=\"row => row.status === 'error' ? 'error-row' : ''\"",
      "impact": "Table re-renders slowly, performance issues"
    }
  ],
  "performanceNotes": [
    {
      "topic": "Client-side vs API mode",
      "description": "Client-side mode loads all data into memory. API mode fetches paginated data from server.",
      "recommendation": "Use client-side for < 1000 rows. Use API mode (fetch-url) for larger datasets to avoid memory issues and slow initial load.",
      "impact": "high"
    },
    {
      "topic": "Row rendering functions",
      "description": "Custom renderers (rowClass, cellRenderer) are called on every render for every visible row.",
      "recommendation": "Keep renderer functions simple. Avoid expensive calculations, API calls, or complex logic. Cache computed values outside the function.",
      "impact": "high"
    },
    {
      "topic": "Data reactivity",
      "description": "Table watches data prop for changes. Deep watching large arrays is expensive.",
      "recommendation": "When updating data, replace the entire array instead of mutating (data.value = [...newData]) to trigger efficient re-renders.",
      "impact": "medium"
    }
  ],
  "accessibilityNotes": [
    {
      "topic": "Table semantics",
      "description": "InDataTable renders semantic HTML table with proper thead, tbody structure.",
      "wcagLevel": "A",
      "recommendation": "Ensure table headers (tableFields.label) are descriptive for screen readers.",
      "example": "{ field: 'email', label: 'User Email Address' } // Descriptive label"
    },
    {
      "topic": "Sortable columns keyboard access",
      "description": "Sortable column headers are keyboard accessible with Enter/Space keys.",
      "wcagLevel": "A",
      "recommendation": "No action needed - component handles keyboard interaction internally.",
      "example": "sortable=\"true\" // Automatically keyboard accessible"
    },
    {
      "topic": "Row selection announcement",
      "description": "Selected rows should be announced to screen readers.",
      "wcagLevel": "AA",
      "recommendation": "Use aria-label on action buttons that operate on selected rows to provide context.",
      "example": "<button :aria-label=\"`Delete ${selectedRows.length} selected items`\">Delete</button>"
    },
    {
      "topic": "Empty state messaging",
      "description": "When table has no data, empty state should be announced.",
      "wcagLevel": "A",
      "recommendation": "Provide meaningful empty-text message that explains why table is empty.",
      "example": "empty-text=\"No users found matching your filters\" // Context for screen readers"
    }
  ],
  "helperFunctions": [
    {
      "name": "createTableField",
      "description": "Create table field definition with common settings",
      "code": "function createTableField(field: string, label: string, options = {}) {\n  return {\n    field,\n    label,\n    sortable: false,\n    width: 'auto',\n    ...options\n  };\n}",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "description": "Data property name"
        },
        {
          "name": "label",
          "type": "string",
          "description": "Column header text"
        },
        {
          "name": "options",
          "type": "object",
          "description": "Additional field options (optional)"
        }
      ],
      "returnType": "object",
      "example": "const nameField = createTableField('name', 'User Name', { sortable: true, width: '200px' });"
    },
    {
      "name": "createSortableFields",
      "description": "Make multiple fields sortable at once",
      "code": "function createSortableFields(fields: Array<{ field: string; label: string }>) {\n  return fields.map(f => ({\n    field: f.field,\n    label: f.label,\n    sortable: true\n  }));\n}",
      "parameters": [
        {
          "name": "fields",
          "type": "Array<{field, label}>",
          "description": "Array of field definitions"
        }
      ],
      "returnType": "Array<object>",
      "example": "const fields = createSortableFields([{ field: 'name', label: 'Name' }, { field: 'date', label: 'Date' }]);"
    },
    {
      "name": "filterTableData",
      "description": "Filter table data by search term across multiple fields",
      "code": "function filterTableData(data: any[], searchTerm: string, searchFields: string[]) {\n  if (!searchTerm) return data;\n  \n  const term = searchTerm.toLowerCase();\n  return data.filter(row => \n    searchFields.some(field => \n      String(row[field] || '').toLowerCase().includes(term)\n    )\n  );\n}",
      "parameters": [
        {
          "name": "data",
          "type": "Array<any>",
          "description": "Table data array"
        },
        {
          "name": "searchTerm",
          "type": "string",
          "description": "Search query"
        },
        {
          "name": "searchFields",
          "type": "Array<string>",
          "description": "Fields to search in"
        }
      ],
      "returnType": "Array<any>",
      "example": "const filtered = filterTableData(users, 'john', ['name', 'email', 'department']);"
    },
    {
      "name": "sortTableData",
      "description": "Sort table data by field and direction",
      "code": "function sortTableData(data: any[], sortBy: string, sortOrder: 'asc' | 'desc' = 'asc') {\n  return [...data].sort((a, b) => {\n    const aVal = a[sortBy];\n    const bVal = b[sortBy];\n    \n    if (aVal === bVal) return 0;\n    \n    const comparison = aVal > bVal ? 1 : -1;\n    return sortOrder === 'asc' ? comparison : -comparison;\n  });\n}",
      "parameters": [
        {
          "name": "data",
          "type": "Array<any>",
          "description": "Table data array"
        },
        {
          "name": "sortBy",
          "type": "string",
          "description": "Field name to sort by"
        },
        {
          "name": "sortOrder",
          "type": "string",
          "description": "Sort direction: 'asc' or 'desc'"
        }
      ],
      "returnType": "Array<any>",
      "example": "const sorted = sortTableData(users, 'name', 'asc');"
    },
    {
      "name": "paginateData",
      "description": "Get paginated slice of data array",
      "code": "function paginateData(data: any[], page: number, perPage: number) {\n  const start = (page - 1) * perPage;\n  const end = start + perPage;\n  \n  return {\n    data: data.slice(start, end),\n    total: data.length,\n    page,\n    perPage,\n    totalPages: Math.ceil(data.length / perPage)\n  };\n}",
      "parameters": [
        {
          "name": "data",
          "type": "Array<any>",
          "description": "Full data array"
        },
        {
          "name": "page",
          "type": "number",
          "description": "Current page number (1-based)"
        },
        {
          "name": "perPage",
          "type": "number",
          "description": "Items per page"
        }
      ],
      "returnType": "{ data: Array<any>, total: number, page: number, perPage: number, totalPages: number }",
      "example": "const paginated = paginateData(users, 2, 25); // Page 2, 25 items per page"
    }
  ]
}
