{
  "component": "InSelect",
  "_metadata": {
    "lastUpdated": "2025-11-25T14:48:39.823Z",
    "propsHash": "f63c4768d755",
    "eventsHash": "c7cf003aa202",
    "propCount": 47,
    "eventCount": 8
  },
  "propEnrichments": {
    "options": {
      "valueFormat": {
        "structure": "Array<Object> or Array<GroupedOptions>",
        "flatStructure": "Array<{ text: string, value: any, disabled?: boolean, description?: string, icon?: string }>",
        "groupedStructure": "Array<{ groupLabel: string, options: Array<{ text: string, value: any }> }>",
        "examples": [
          "[{ text: 'Option 1', value: 1 }]",
          "[{ text: 'Active', value: 'active', icon: 'check' }]",
          "[{ groupLabel: 'Group 1', options: [{ text: 'Opt 1', value: 1 }] }]"
        ],
        "requiredKeys": [
          "text",
          "value"
        ],
        "optionalKeys": [
          "disabled",
          "description",
          "icon",
          "groupLabel"
        ],
        "notes": "CRITICAL: Property is 'text' not 'label'! Supports both flat and grouped options.",
        "typescript": "Array<{ text: string; value: any; disabled?: boolean; description?: string; icon?: string }> | Array<{ groupLabel: string; options: Array<{ text: string; value: any }> }>"
      },
      "relatedProps": [
        "value",
        "searchStatus",
        "lazyLoad"
      ],
      "commonMistakes": [
        {
          "mistake": "Using 'label' instead of 'text' property",
          "impact": "Options won't display, shows empty dropdown",
          "fix": "Change { label: 'X' } to { text: 'X' }",
          "severity": "critical",
          "detectPattern": "options.*label:"
        },
        {
          "mistake": "Passing array of strings instead of objects",
          "impact": "Component expects objects with text/value",
          "fix": "Transform ['opt1', 'opt2'] to [{ text: 'opt1', value: 'opt1' }]",
          "severity": "critical"
        },
        {
          "mistake": "Not providing unique values",
          "impact": "Selection tracking fails",
          "fix": "Ensure each option has unique value property",
          "severity": "high"
        }
      ]
    },
    "value": {
      "valueFormat": {
        "structure": "Array<Object>",
        "objectShape": "{ text: string, value: any }",
        "examples": [
          "[]",
          "[{ text: 'Option 1', value: 1 }]",
          "[{ text: 'Active', value: 'active' }, { text: 'Pending', value: 'pending' }]"
        ],
        "notes": "CRITICAL: Always array, even for single selection. Empty array = no selection. Contains selected option object(s).",
        "typescript": "Array<{ text: string; value: any }>"
      },
      "relatedEvents": [
        "optionClick"
      ],
      "commonMistakes": [
        {
          "mistake": "Passing single object instead of array",
          "impact": "Type error, selection won't work",
          "fix": "Wrap in array: [selectedOption]",
          "severity": "critical"
        },
        {
          "mistake": "Passing just value without text",
          "impact": "Selected text won't display",
          "fix": "Use { text: 'Display', value: actualValue }",
          "severity": "high"
        },
        {
          "mistake": "Not syncing with v-model pattern",
          "impact": "Component won't update on selection",
          "fix": "Listen to @optionClick and update value prop",
          "severity": "high"
        }
      ]
    },
    "staticPosition": {
      "valueFormat": {
        "structure": "string (enum)",
        "validValues": [
          "bottom left",
          "bottom right",
          "top left",
          "top right"
        ],
        "default": "bottom left",
        "notes": "Dropdown menu position relative to button",
        "typescript": "'bottom left' | 'bottom right' | 'top left' | 'top right'"
      },
      "relatedProps": [
        "dynamicPosition"
      ],
      "possibleValues": [
        {
          "value": "bottom left",
          "description": "TODO: Add description for 'bottom left'"
        },
        {
          "value": "bottom right",
          "description": "TODO: Add description for 'bottom right'"
        },
        {
          "value": "top left",
          "description": "TODO: Add description for 'top left'"
        },
        {
          "value": "top right",
          "description": "TODO: Add description for 'top right'"
        }
      ]
    },
    "staticChildPosition": {
      "valueFormat": {
        "structure": "string (enum)",
        "validValues": [
          "bottom left",
          "bottom right",
          "top left",
          "top right"
        ],
        "default": "bottom right",
        "notes": "Child dropdown position for grouped options",
        "typescript": "'bottom left' | 'bottom right' | 'top left' | 'top right'"
      },
      "possibleValues": [
        {
          "value": "bottom left",
          "description": "TODO: Add description for 'bottom left'"
        },
        {
          "value": "bottom right",
          "description": "TODO: Add description for 'bottom right'"
        },
        {
          "value": "top left",
          "description": "TODO: Add description for 'top left'"
        },
        {
          "value": "top right",
          "description": "TODO: Add description for 'top right'"
        }
      ]
    },
    "optionValidationType": {
      "valueFormat": {
        "structure": "string | RegExp",
        "validValues": [
          "all",
          "number",
          "text"
        ],
        "notes": "Validation type for create new option feature",
        "typescript": "'all' | 'number' | 'text' | RegExp"
      },
      "relatedProps": [
        "createOptionStatus"
      ]
    },
    "state": {
      "valueFormat": {
        "structure": "string (enum)",
        "validValues": [
          "default",
          "success",
          "warning",
          "error"
        ],
        "default": "default",
        "notes": "Visual state for validation feedback",
        "typescript": "'default' | 'success' | 'warning' | 'error'"
      },
      "relatedProps": [
        "stateMessage"
      ]
    }
  },
  "eventEnrichments": {
    "optionClick": {
      "payloadTypes": [
        {
          "condition": "Always",
          "type": "Object",
          "format": "{ text: string, value: any }",
          "example": "{ text: 'Option 1', value: 1 }"
        }
      ],
      "useCase": "Main selection event. Update value prop with this payload to reflect selection",
      "handlingPattern": "@optionClick=\"handleSelect\"\n\nhandleSelect(option) {\n  this.selectedValue = [option]; // Always wrap in array!\n  // Or for v-model pattern:\n  this.$emit('update:modelValue', [option]);\n}",
      "commonMistakes": [
        {
          "mistake": "Not wrapping payload in array when updating value",
          "impact": "Type mismatch, component breaks",
          "fix": "Always use [payload]",
          "severity": "critical"
        }
      ]
    },
    "search": {
      "payloadTypes": [
        {
          "condition": "When searchStatus=true",
          "type": "string",
          "example": "\"search query\""
        }
      ],
      "useCase": "Emitted when user types in search box. Use to filter options or lazy load",
      "relatedProps": [
        "searchStatus",
        "lazyLoadSearch"
      ]
    },
    "endScroll": {
      "payloadTypes": [
        {
          "condition": "When lazyLoad=true and user scrolls to bottom",
          "type": "void",
          "example": "undefined"
        }
      ],
      "useCase": "Infinite scroll support. Load more options when emitted",
      "handlingPattern": "@endScroll=\"loadMore\"\n\ndata() {\n  return { page: 1, allOptions: [] };\n},\nmethods: {\n  loadMore() {\n    this.page++;\n    this.fetchOptions(this.page).then(newOptions => {\n      this.allOptions = [...this.allOptions, ...newOptions];\n    });\n  }\n}",
      "relatedProps": [
        "lazyLoad",
        "fetchPage"
      ]
    },
    "addOption": {
      "payloadTypes": [
        {
          "condition": "When createOptionStatus=true and user creates new option",
          "type": "Object",
          "format": "{ text: string, value: string }",
          "example": "{ text: 'New Option', value: 'New Option' }"
        }
      ],
      "useCase": "User created a new option via 'create' button",
      "handlingPattern": "@addOption=\"handleAddOption\"\n\nhandleAddOption(newOption) {\n  // Add to options array\n  this.options = [...this.options, newOption];\n  // Select it\n  this.selectedValue = [newOption];\n}",
      "relatedProps": [
        "createOptionStatus",
        "createButtonLabel"
      ]
    },
    "secondaryButtonClick": {
      "payloadTypes": [
        {
          "condition": "When buttonStatus=true",
          "type": "void"
        }
      ],
      "useCase": "Secondary action button clicked (shown in dropdown footer)",
      "relatedProps": [
        "buttonStatus",
        "buttonLabel",
        "buttonIcon"
      ]
    }
  },
  "examples": [
    {
      "title": "Basic Single Select",
      "description": "Simple dropdown with static options",
      "complexity": "beginner",
      "code": "<template>\n  <InSelect\n    id=\"status-select\"\n    label-text=\"Status\"\n    placeholder-text=\"Select status\"\n    :options=\"statusOptions\"\n    :value=\"selectedStatus\"\n    @optionClick=\"handleSelect\" />\n</template>\n\n<script>\nimport { InSelect } from '@useinsider/design-system-vue';\n\nexport default {\n  components: { InSelect },\n  data() {\n    return {\n      statusOptions: [\n        { text: 'Active', value: 'active' },\n        { text: 'Pending', value: 'pending' },\n        { text: 'Inactive', value: 'inactive' }\n      ],\n      selectedStatus: [] // Empty = no selection\n    };\n  },\n  methods: {\n    handleSelect(option) {\n      this.selectedStatus = [option]; // CRITICAL: Always array!\n      console.log('Selected:', option.value);\n    }\n  }\n};\n</script>"
    },
    {
      "title": "With Search and Icons",
      "description": "Searchable dropdown with icons",
      "complexity": "intermediate",
      "code": "<template>\n  <InSelect\n    id=\"country-select\"\n    label-text=\"Country\"\n    placeholder-text=\"Search countries...\"\n    :search-status=\"true\"\n    :options=\"countryOptions\"\n    :value=\"selectedCountry\"\n    @optionClick=\"handleSelect\"\n    @search=\"handleSearch\" />\n</template>\n\n<script>\nimport { InSelect } from '@useinsider/design-system-vue';\n\nexport default {\n  components: { InSelect },\n  data() {\n    return {\n      allCountries: [\n        { text: 'United States', value: 'US', icon: 'flag-us' },\n        { text: 'United Kingdom', value: 'UK', icon: 'flag-uk' },\n        { text: 'Turkey', value: 'TR', icon: 'flag-tr' },\n        // ... more countries\n      ],\n      countryOptions: [],\n      selectedCountry: []\n    };\n  },\n  created() {\n    this.countryOptions = this.allCountries;\n  },\n  methods: {\n    handleSelect(option) {\n      this.selectedCountry = [option];\n    },\n    handleSearch(query) {\n      if (!query) {\n        this.countryOptions = this.allCountries;\n        return;\n      }\n      this.countryOptions = this.allCountries.filter(country =>\n        country.text.toLowerCase().includes(query.toLowerCase())\n      );\n    }\n  }\n};\n</script>"
    },
    {
      "title": "Lazy Loading with Infinite Scroll",
      "description": "Load options on scroll for large datasets",
      "complexity": "advanced",
      "code": "<template>\n  <InSelect\n    id=\"user-select\"\n    label-text=\"Select User\"\n    :search-status=\"true\"\n    :lazy-load=\"true\"\n    :lazy-load-search=\"true\"\n    :fetch-page=\"currentPage\"\n    :options=\"users\"\n    :value=\"selectedUser\"\n    :loading-state=\"isLoading\"\n    @optionClick=\"handleSelect\"\n    @search=\"handleSearch\"\n    @endScroll=\"loadMore\" />\n</template>\n\n<script>\nimport { InSelect } from '@useinsider/design-system-vue';\n\nexport default {\n  components: { InSelect },\n  data() {\n    return {\n      users: [],\n      selectedUser: [],\n      currentPage: 1,\n      isLoading: false,\n      searchQuery: ''\n    };\n  },\n  created() {\n    this.loadUsers();\n  },\n  methods: {\n    async loadUsers() {\n      this.isLoading = true;\n      try {\n        const response = await fetch(\n          `/api/users?page=${this.currentPage}&search=${this.searchQuery}`\n        );\n        const data = await response.json();\n        \n        // Transform API response to select format\n        const newUsers = data.users.map(u => ({\n          text: u.name,\n          value: u.id,\n          description: u.email\n        }));\n        \n        this.users = [...this.users, ...newUsers];\n      } finally {\n        this.isLoading = false;\n      }\n    },\n    \n    loadMore() {\n      this.currentPage++;\n      this.loadUsers();\n    },\n    \n    handleSearch(query) {\n      this.searchQuery = query;\n      this.currentPage = 1;\n      this.users = []; // Clear existing\n      this.loadUsers();\n    },\n    \n    handleSelect(option) {\n      this.selectedUser = [option];\n    }\n  }\n};\n</script>"
    },
    {
      "title": "Grouped Options",
      "description": "Options organized in groups",
      "complexity": "advanced",
      "code": "<template>\n  <InSelect\n    id=\"product-select\"\n    label-text=\"Select Product\"\n    :options=\"productOptions\"\n    :value=\"selectedProduct\"\n    @optionClick=\"handleSelect\" />\n</template>\n\n<script>\nimport { InSelect } from '@useinsider/design-system-vue';\n\nexport default {\n  components: { InSelect },\n  data() {\n    return {\n      productOptions: [\n        {\n          groupLabel: 'Marketing',\n          options: [\n            { text: 'Email Marketing', value: 'email' },\n            { text: 'SMS Marketing', value: 'sms' }\n          ]\n        },\n        {\n          groupLabel: 'Analytics',\n          options: [\n            { text: 'Web Analytics', value: 'web' },\n            { text: 'Mobile Analytics', value: 'mobile' }\n          ]\n        }\n      ],\n      selectedProduct: []\n    };\n  },\n  methods: {\n    handleSelect(option) {\n      this.selectedProduct = [option];\n    }\n  }\n};\n</script>"
    }
  ],
  "helperFunctions": [
    {
      "name": "transformToSelectOptions",
      "description": "Transform API data to InSelect format",
      "code": "transformToSelectOptions(items, textKey = 'name', valueKey = 'id') {\n  return items.map(item => ({\n    text: item[textKey],\n    value: item[valueKey]\n  }));\n}",
      "typescript": "transformToSelectOptions<T>(items: T[], textKey: keyof T, valueKey: keyof T): Array<{ text: string; value: any }>",
      "usedFor": [
        "options transformation"
      ]
    },
    {
      "name": "getSelectedValue",
      "description": "Extract value from InSelect value prop",
      "code": "getSelectedValue(selectValue) {\n  return selectValue[0]?.value || null;\n}",
      "typescript": "getSelectedValue(selectValue: Array<{ text: string; value: any }>): any | null",
      "usedFor": [
        "extracting selected value"
      ]
    }
  ],
  "codeSnippets": {
    "basicSelect": {
      "title": "Basic Select",
      "description": "Simple single-select dropdown",
      "code": "<script setup>\nimport { ref } from 'vue';\nimport { InSelect } from '@useinsider/design-system-vue';\n\nconst options = [\n  { text: 'Option 1', value: 1 },\n  { text: 'Option 2', value: 2 },\n  { text: 'Option 3', value: 3 }\n];\n\nconst selected = ref([]);\n</script>\n\n<template>\n  <InSelect\n    id=\"basic-select\"\n    label-text=\"Choose an option\"\n    :options=\"options\"\n    :value=\"selected\"\n    @change=\"selected = $event\"\n  />\n</template>"
    },
    "searchableSelect": {
      "title": "Searchable Select",
      "description": "Large list with search",
      "code": "<script setup>\nimport { ref, computed } from 'vue';\n\nconst allCountries = ref([...]);\nconst searchQuery = ref('');\nconst selected = ref([]);\n\nconst filteredOptions = computed(() => {\n  if (!searchQuery.value) return allCountries.value;\n  return allCountries.value.filter(c => \n    c.text.toLowerCase().includes(searchQuery.value.toLowerCase())\n  );\n});\n</script>\n\n<template>\n  <InSelect\n    label-text=\"Country\"\n    search-status\n    :options=\"filteredOptions\"\n    :value=\"selected\"\n    @search=\"searchQuery = $event\"\n    @change=\"selected = $event\"\n  />\n</template>"
    },
    "validatedSelect": {
      "title": "Select with Validation",
      "description": "Required field with validation",
      "code": "<script setup>\nimport { ref, computed } from 'vue';\n\nconst selected = ref([]);\n\nconst state = computed(() => {\n  if (selected.value.length === 0) return 'error';\n  return 'success';\n});\n\nconst stateMessage = computed(() => \n  selected.value.length === 0 ? 'Please select an option' : ''\n);\n</script>\n\n<template>\n  <InSelect\n    label-text=\"Required Field *\"\n    :options=\"options\"\n    :value=\"selected\"\n    :state=\"state\"\n    :state-message=\"stateMessage\"\n    @change=\"selected = $event\"\n  />\n</template>"
    }
  },
  "styling": {
    "cssVariables": {
      "--select-bg": "Dropdown background (default: white)",
      "--select-text": "Text color",
      "--select-border": "Border color",
      "--select-border-focus": "Border color on focus",
      "--select-option-hover": "Option hover background",
      "--select-max-height": "Dropdown max height (default: 300px)"
    },
    "classes": {
      "in-select": "Root container",
      "in-select__label": "Label text",
      "in-select__input": "Selected value display",
      "in-select__dropdown": "Dropdown panel",
      "in-select__option": "Dropdown option",
      "in-select__option--selected": "Selected option",
      "in-select__option--disabled": "Disabled option",
      "in-select__search": "Search input",
      "in-select__placeholder": "Placeholder text"
    },
    "notes": "Use CSS variables for theming. Component automatically handles focus states."
  },
  "implementationPatterns": [
    {
      "name": "Form Field Select",
      "description": "Select as part of form with validation",
      "code": "<script setup>\nimport { ref, computed } from 'vue';\nimport { InSelect } from '@useinsider/design-system-vue';\n\nconst formData = ref({\n  country: [],\n  status: []\n});\n\nconst countries = [\n  { text: 'Turkey', value: 'TR' },\n  { text: 'USA', value: 'US' },\n  { text: 'UK', value: 'GB' }\n];\n\nconst validateForm = () => {\n  return formData.value.country.length > 0 && \n         formData.value.status.length > 0;\n};\n</script>\n\n<template>\n  <form @submit.prevent=\"handleSubmit\">\n    <InSelect\n      id=\"country\"\n      label-text=\"Country *\"\n      :options=\"countries\"\n      :value=\"formData.country\"\n      :state=\"formData.country.length === 0 ? 'error' : 'default'\"\n      @change=\"formData.country = $event\"\n    />\n    \n    <button :disabled=\"!validateForm()\" type=\"submit\">\n      Submit\n    </button>\n  </form>\n</template>",
      "when": "Building forms with required select fields",
      "pros": [
        "Clear validation",
        "User feedback",
        "Form state management"
      ],
      "cons": [
        "Requires validation logic",
        "More boilerplate"
      ]
    },
    {
      "name": "Dynamic Options Select",
      "description": "Load options from API",
      "code": "<script setup>\nimport { ref, onMounted } from 'vue';\nimport { InSelect } from '@useinsider/design-system-vue';\n\nconst options = ref([]);\nconst selected = ref([]);\nconst loading = ref(false);\n\nconst loadOptions = async () => {\n  loading.value = true;\n  try {\n    const response = await fetch('/api/options');\n    const data = await response.json();\n    options.value = data.map(item => ({\n      text: item.name,\n      value: item.id\n    }));\n  } catch (error) {\n    console.error('Failed to load options:', error);\n  } finally {\n    loading.value = false;\n  }\n};\n\nonMounted(() => {\n  loadOptions();\n});\n</script>\n\n<template>\n  <InSelect\n    label-text=\"Select Item\"\n    :options=\"options\"\n    :value=\"selected\"\n    :loading-status=\"loading\"\n    @change=\"selected = $event\"\n  />\n</template>",
      "when": "Options come from API/database",
      "pros": [
        "Fresh data",
        "Dynamic content",
        "Scalable"
      ],
      "cons": [
        "Loading state needed",
        "Network dependency",
        "Error handling"
      ]
    },
    {
      "name": "Dependent Selects",
      "description": "Cascading dropdown selections",
      "code": "<script setup>\nimport { ref, computed, watch } from 'vue';\nimport { InSelect } from '@useinsider/design-system-vue';\n\nconst selectedCountry = ref([]);\nconst selectedCity = ref([]);\n\nconst countries = [\n  { text: 'Turkey', value: 'TR' },\n  { text: 'USA', value: 'US' }\n];\n\nconst allCities = {\n  TR: [\n    { text: 'Istanbul', value: 'IST' },\n    { text: 'Ankara', value: 'ANK' }\n  ],\n  US: [\n    { text: 'New York', value: 'NYC' },\n    { text: 'Los Angeles', value: 'LAX' }\n  ]\n};\n\nconst cities = computed(() => {\n  if (selectedCountry.value.length === 0) return [];\n  const countryCode = selectedCountry.value[0].value;\n  return allCities[countryCode] || [];\n});\n\n// Reset city when country changes\nwatch(selectedCountry, () => {\n  selectedCity.value = [];\n});\n</script>\n\n<template>\n  <div>\n    <InSelect\n      id=\"country\"\n      label-text=\"Country\"\n      :options=\"countries\"\n      :value=\"selectedCountry\"\n      @change=\"selectedCountry = $event\"\n    />\n    \n    <InSelect\n      id=\"city\"\n      label-text=\"City\"\n      :options=\"cities\"\n      :value=\"selectedCity\"\n      :disabled=\"selectedCountry.length === 0\"\n      @change=\"selectedCity = $event\"\n    />\n  </div>\n</template>",
      "when": "Hierarchical or dependent selections",
      "pros": [
        "Contextual options",
        "Data integrity",
        "Good UX"
      ],
      "cons": [
        "Complex state management",
        "Reset logic needed"
      ]
    }
  ],
  "useCases": [
    {
      "title": "Country Selection",
      "description": "Select country from dropdown",
      "example": "<InSelect\n  label-text=\"Country\"\n  :options=\"countries\"\n  :value=\"selectedCountry\"\n  search-status\n  @change=\"selectedCountry = $event\"\n/>"
    },
    {
      "title": "Status Filter",
      "description": "Filter items by status",
      "example": "<InSelect\n  label-text=\"Status\"\n  :options=\"[\n    { text: 'Active', value: 'active' },\n    { text: 'Pending', value: 'pending' },\n    { text: 'Inactive', value: 'inactive' }\n  ]\"\n  :value=\"statusFilter\"\n  @change=\"applyStatusFilter\"\n/>"
    },
    {
      "title": "User Role Assignment",
      "description": "Assign role to user",
      "example": "<InSelect\n  label-text=\"Role\"\n  :options=\"roles\"\n  :value=\"userRole\"\n  @change=\"updateUserRole\"\n/>"
    },
    {
      "title": "Language Selector",
      "description": "Choose application language",
      "example": "<InSelect\n  label-text=\"Language\"\n  :options=\"languages\"\n  :value=\"currentLanguage\"\n  @change=\"changeLanguage\"\n/>"
    }
  ],
  "bestPractices": [
    {
      "title": "Always Provide Label Text",
      "description": "Every select needs a descriptive label",
      "code": "// Good\n<InSelect label-text=\"Country\" />\n\n// Avoid\n<InSelect />",
      "reasoning": "Labels improve accessibility and UX"
    },
    {
      "title": "Use Search for Long Lists",
      "description": "Enable search for 10+ options",
      "code": "<InSelect\n  :options=\"longList\"\n  search-status\n  @search=\"handleSearch\"\n/>",
      "reasoning": "Easier navigation for users with many options"
    },
    {
      "title": "Provide Meaningful Option Text",
      "description": "Option text should be clear and descriptive",
      "code": "// Good\n{ text: 'United States', value: 'US' }\n\n// Avoid\n{ text: 'US', value: 'US' }",
      "reasoning": "Clear text improves usability and accessibility"
    },
    {
      "title": "Handle Empty State",
      "description": "Show message when no options available",
      "code": "<InSelect\n  v-if=\"options.length > 0\"\n  :options=\"options\"\n/>\n<p v-else>No options available</p>",
      "reasoning": "Better UX when options are loading or empty"
    }
  ],
  "commonMistakes": [
    {
      "mistake": "Using 'label' instead of 'text' in options",
      "why": "Component expects 'text' property",
      "impact": "Options won't display correctly",
      "fix": "Use { text: 'Display', value: 'val' } format",
      "severity": "critical",
      "example": "// Wrong:\n{ label: 'Option 1', value: 1 }\n\n// Correct:\n{ text: 'Option 1', value: 1 }"
    },
    {
      "mistake": "Passing single value instead of array",
      "why": "InSelect value prop expects array format",
      "impact": "Component won't work, type error",
      "fix": "Wrap in array: [{ text: 'X', value: 'x' }]",
      "severity": "critical",
      "example": "// Wrong:\nvalue=\"selected\"\n\n// Correct:\nvalue=\"[selected]\""
    },
    {
      "mistake": "Not handling empty selection",
      "why": "value array can be empty",
      "impact": "Errors when accessing value[0]",
      "fix": "Check length before accessing: value[0]?.value",
      "severity": "high",
      "example": "// Wrong:\nconst val = selected[0].value;\n\n// Correct:\nconst val = selected[0]?.value || null;"
    }
  ],
  "performanceNotes": [
    {
      "topic": "Large option lists",
      "description": "Filtering large arrays on every search keystroke causes UI lag",
      "recommendation": "Debounce search handler or use lazy loading for 1000+ options",
      "impact": "medium"
    },
    {
      "topic": "Options array reference",
      "description": "Passing new options array reference on every render causes re-renders",
      "recommendation": "Store options in data() or use computed with proper dependencies",
      "impact": "low"
    }
  ],
  "accessibilityNotes": [
    {
      "topic": "Label requirement",
      "description": "Select must have associated label for screen readers",
      "wcagLevel": "A",
      "recommendation": "Always provide label-text prop",
      "example": "<InSelect label-text=\"Country\" :options=\"countries\" />"
    },
    {
      "topic": "Meaningful option text",
      "description": "Option text is announced by screen readers",
      "wcagLevel": "A",
      "recommendation": "Use descriptive text, not codes or abbreviations",
      "example": "// Good: { text: 'United States', value: 'US' }\n// Avoid: { text: 'US', value: 'US' }"
    },
    {
      "topic": "Keyboard navigation",
      "description": "Select must be fully keyboard accessible",
      "wcagLevel": "A",
      "recommendation": "Arrow keys navigate options, Enter selects, Escape closes",
      "example": "// Automatically supported by component"
    }
  ]
}
